<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PixiJS Tower Defense</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#181c25">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>    <style>
        * {
            box-sizing: border-box;
        }        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #181c25;
            font-family: 'Segoe UI', Arial, sans-serif;
            /* Handle iOS Safari viewport issues */
            -webkit-overflow-scrolling: touch;
            position: fixed;
            top: 0;
            left: 0;
        }
        
        /* Ensure full viewport coverage on iOS Safari */
        @supports (height: 100dvh) {
            html, body {
                height: 100dvh; /* Dynamic viewport height for modern browsers */
            }
        }
          /* Fallback for older browsers and additional Safari support */
        @media screen and (max-width: 768px) {
            html, body {
                height: 100vh;
                height: -webkit-fill-available; /* Safari iOS specific */
                height: calc(var(--vh, 1vh) * 100); /* Use JS calculated height as fallback */
            }
        }/* Mobile First - Stack vertically */
        #game-wrapper {
            display: flex;
            flex-direction: column;
            width: 100vw;
            height: 100vh;
            height: -webkit-fill-available; /* Safari iOS specific */
        }
        
        /* Support for newer viewport units */
        @supports (height: 100dvh) {
            #game-wrapper {
                height: 100dvh;
            }
        }

        #game-canvas-container {
            flex: 1;
            width: 100%;
            position: relative;
            background: #333;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-canvas-container canvas {
            max-width: 100%;
            max-height: 100%;
            display: block;
        }        #game-ui {
            flex: 0 0 auto;
            width: 100%;
            max-height: 40vh;
            max-height: 40dvh; /* Use dynamic viewport height when available */
            min-height: 200px;
            background: rgba(24, 28, 37, 0.95);
            border-top: 2px solid #4e6fae;
            padding: 10px;
            padding-bottom: max(10px, env(safe-area-inset-bottom)); /* Handle iPhone notch/home indicator */
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
            pointer-events: auto;
        }/* Desktop - Side by side */
        @media (min-width: 769px) {
            #game-wrapper {
                flex-direction: row;
                padding: 10px;
                gap: 20px;
            }

            #game-canvas-container {
                flex: 1;
                max-width: 800px;
                max-height: 800px;
                aspect-ratio: 1;
            }

            #game-ui {
                flex: 0 0 350px;
                max-height: 800px;
                border-top: none;
                border-left: 2px solid #4e6fae;
            }
        }        /* Mobile Layout - reorganize UI */
        @media (max-width: 768px) {            /* Additional iOS Safari specific fixes */
            #game-wrapper {
                height: 100vh;
                height: -webkit-fill-available;
                height: calc(var(--vh, 1vh) * 100); /* Use JS calculated height */
            }
            
            @supports (height: 100dvh) {
                #game-wrapper {
                    height: 100dvh;
                }
            }
            
            #game-canvas-container {
                /* Ensure canvas container takes available space minus UI */
                flex: 1;
                min-height: 0; /* Important for flex children */
            }
            
            #game-ui {
                flex-direction: row;
                gap: 10px;
                padding: 8px;
                padding-bottom: max(8px, env(safe-area-inset-bottom));
                /* Adjust max height to account for Safari UI */
                max-height: min(40vh, 40dvh);
            }
        }
        
        /* Landscape orientation specific fixes for mobile */
        @media (max-width: 768px) and (orientation: landscape) {
            #game-ui {
                /* Reduce UI height significantly in landscape mode */
                max-height: min(25vh, 25dvh);
                min-height: 180px;
                padding: 6px;
                padding-bottom: max(6px, env(safe-area-inset-bottom));
                gap: 8px;
            }
            
            #game-canvas-container {
                /* Give more space to the game canvas in landscape */
                flex: 1;
                min-height: 0;
            }
            
            /* Make UI elements more compact in landscape */
            .mobile-control-section {
                padding: 6px;
                min-height: 50px;
                gap: 2px;
            }
            
            .mobile-control-section button {
                font-size: 0.75em !important;
                padding: 4px 8px !important;
                min-height: 32px;
            }
            
            .mobile-control-section #live-stats-mobile {
                font-size: 0.75em;
                padding: 4px 6px;
                line-height: 1.3;
            }
            
            .mobile-control-section #bomb-count-mobile {
                font-size: 0.75em;
            }
            
            .mobile-control-section #place-bomb-btn-mobile {
                font-size: 0.6em !important;
                padding: 2px 4px !important;
                min-height: 26px;
            }
            
            .mobile-control-section #wave-info-content-mobile {
                font-size: 0.7em;
                line-height: 1.2;
                gap: 2px;
                padding: 3px;
            }
            
            .mobile-control-section #wave-info-content-mobile .wave-info-item {
                padding: 1px 3px;
                font-size: 0.85em;
            }
            
            .towers-mobile-title {
                font-size: 1em;
                margin-bottom: 3px;
                padding: 3px;
            }
            
            .towers-mobile-content .tower-btn {
                height: 36px;
                font-size: 0.65em;
                padding: 3px 5px;
            }
            
            .mobile-control-title {
                font-size: 0.8em !important;
                margin-bottom: 3px;
                padding: 1px 3px;
            }
            
            .mobile-control-section[data-section="next-waves"] .mobile-control-title {
                font-size: 0.65em !important;
                margin-bottom: 1px;
                padding: 1px 2px;
            }        }
        
        /* Base mobile styles for both portrait and landscape */
        @media (max-width: 768px) {
            /* Hide desktop layout components on mobile */
            .desktop-layout {
                display: none !important;
            }
            
            /* Mobile layout container */
            .mobile-layout {
                display: flex;
                flex-direction: row;
                width: 100%;
                gap: 10px;
                height: 100%;
            }
            
            /* Left side - Towers section */
            .towers-mobile-section {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 6px;
                max-width: 45%;
            }
            
            .towers-mobile-title {
                font-size: 1.1em;
                font-weight: bold;
                color: white;
                text-align: center;
                margin-bottom: 4px;
                padding: 4px;
                background: rgba(30,34,44,0.8);
                border-radius: 4px;
            }            .towers-mobile-content {
                flex: 1;
                display: flex;
                flex-direction: column;
                gap: 4px;
                overflow-y: auto; /* Add scrolling for towers */
                max-height: 100%;
                padding-right: 2px; /* Space for scrollbar */
            }
            
            /* Custom scrollbar for tower selection */
            .towers-mobile-content::-webkit-scrollbar {
                width: 4px;
            }
            
            .towers-mobile-content::-webkit-scrollbar-track {
                background: rgba(30,34,44,0.5);
                border-radius: 2px;
            }
            
            .towers-mobile-content::-webkit-scrollbar-thumb {
                background: rgba(78, 111, 174, 0.7);
                border-radius: 2px;
            }
            
            .towers-mobile-content::-webkit-scrollbar-thumb:hover {
                background: rgba(110, 143, 222, 0.9);            }            /* Right side - Controls grid */
            .controls-mobile-grid {
                flex: 1;
                display: grid;
                grid-template-columns: 1fr 1fr;
                grid-template-rows: auto auto auto auto;
                gap: 6px;
                max-width: 55%;
                align-content: start;
                height: 100%;
            }
              /* Mobile control sections */
            .mobile-control-section {
                display: flex;
                flex-direction: column;
                gap: 3px;
                padding: 8px;
                background: rgba(30,34,44,0.9);
                border-radius: 6px;
                min-height: 60px;
                border: 1px solid rgba(78, 111, 174, 0.3);
                justify-content: center;
            }            .mobile-control-title {
                font-size: 0.85em;
                font-weight: bold;
                color: #ffffff;
                text-align: center;
                margin-bottom: 4px;
                padding: 2px 4px;
                background: rgba(78, 111, 174, 0.6);
                border-radius: 4px;
                text-shadow: 0 1px 2px rgba(0,0,0,0.7);
                display: block; /* Show titles for Next Waves */
            }
            
            /* Hide titles for most sections except Next Waves */
            .mobile-control-section:not([data-section="next-waves"]) .mobile-control-title {
                display: none;
            }
            
            /* Make Next Waves header smaller and more compact */
            .mobile-control-section[data-section="next-waves"] .mobile-control-title {
                font-size: 0.7em;
                margin-bottom: 2px;
                padding: 1px 3px;
            }
              /* Compact mobile buttons */
            .mobile-control-section button {
                font-size: 0.8em !important;
                padding: 6px 10px !important;
                margin: 0 !important;
                min-height: 36px;
                background: #4e6fae !important;
                border: none !important;
                border-radius: 4px !important;
                color: white !important;
                font-weight: 600;
                transition: background 0.2s;
                text-shadow: 0 1px 2px rgba(0,0,0,0.5);
            }
            
            .mobile-control-section button:hover {
                background: #6e8fde !important;
            }
            
            .mobile-control-section button:disabled {
                background: #666 !important;
                cursor: not-allowed;
            }
              /* Compact mobile stats */
            .mobile-control-section #live-stats-mobile {
                font-size: 0.8em;
                padding: 6px 8px;
                margin: 0;
                text-align: center;
                line-height: 1.4;
                background: rgba(30,34,44,0.95);
                border-radius: 4px;
                border: 1px solid rgba(78, 111, 174, 0.2);
                color: #ffffff;
                text-shadow: 0 1px 2px rgba(0,0,0,0.7);
                font-weight: 500;
            }
              /* Compact bomb UI for mobile */
            .mobile-control-section #bomb-ui-mobile {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 6px;
                font-size: 0.8em;
            }
            
            .mobile-control-section #bomb-count-mobile {
                font-size: 0.8em;
                margin: 0;
                text-align: center;
                color: #ffffff;
                font-weight: 600;
                text-shadow: 0 1px 2px rgba(0,0,0,0.7);
            }
            
            .mobile-control-section #place-bomb-btn-mobile {
                background: #ff3300 !important;
                font-size: 0.65em !important;
                padding: 3px 6px !important;
                min-height: 28px;
            }
            
            .mobile-control-section #place-bomb-btn-mobile:hover:not(:disabled) {
                background: #ff5500 !important;
            }
              /* Compact wave info for mobile */
            .mobile-control-section #wave-info-panel-mobile {
                flex: 1;
                display: flex;
                flex-direction: column;
                min-height: 80px;
            }
            
            .mobile-control-section #wave-info-content-mobile {
                flex: 1;
                max-height: none;
                overflow-y: auto;
                font-size: 0.75em;
                line-height: 1.3;
                display: flex;
                flex-direction: column;
                gap: 3px;
                padding: 4px;
            }
            
            .mobile-control-section #wave-info-content-mobile .wave-info-item {
                display: flex;
                align-items: center;
                padding: 2px 4px;
                border-radius: 3px;
                font-size: 0.9em;
                color: #ffffff;
                text-shadow: 0 1px 2px rgba(0,0,0,0.7);
                font-weight: 500;
            }
            
            .mobile-control-section #wave-info-content-mobile .wave-info-item.current {
                background: rgba(110, 143, 222, 0.3);
                border: 1px solid #6e8fde;
            }
              /* Mobile tower buttons */
            .towers-mobile-content .tower-btn {
                height: 40px;
                font-size: 0.7em;
                padding: 4px 6px;
                line-height: 1;
                border-radius: 6px;
                color: #fff;
                cursor: pointer;
                transition: all 0.2s;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                margin-bottom: 4px;
                text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
                border: 2px solid rgba(255,255,255,0.3);
                box-shadow: inset 0 1px 3px rgba(255,255,255,0.2);
            }
            
            .towers-mobile-content .tower-btn:hover {
                transform: translateY(-1px);
                box-shadow: 0 2px 6px rgba(0,0,0,0.3), inset 0 1px 3px rgba(255,255,255,0.3);
            }
            
            .towers-mobile-content .tower-btn.selected {
                border: 2px solid #ffd700;
                box-shadow: 0 0 8px rgba(255,215,0,0.5), inset 0 1px 3px rgba(255,255,255,0.3);
            }
            
            /* Mobile tower select container */
            .towers-mobile-content #tower-select-mobile {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 4px;
                width: 100%;
            }            
            .towers-mobile-content .tower-btn:hover,
            .towers-mobile-content .tower-btn.selected {
                /* Color handled by individual button styling */
            }/* Next Waves section - fills empty space to right of bombs and end game */
            .mobile-control-section[data-section="next-waves"] {
                grid-column: 2;
                grid-row: 3 / 5; /* Span rows 3-4 (next to bombs and end game) */
                background: rgba(30,34,44,0.95);
                border: 1px solid rgba(78, 111, 174, 0.4);
                min-height: 120px;
                display: flex;
                flex-direction: column;
            }
              /* End game button positioning - goes under bombs in row 4, column 1 */
            .mobile-control-section[data-section="end-game"] {
                grid-column: 1;
                grid-row: 4;
                background: rgba(222, 110, 110, 0.2);
                border: 1px solid rgba(222, 110, 110, 0.5);
                align-self: start;
            }
            
            .mobile-control-section[data-section="end-game"] button {
                background: #de6e6e !important;
                font-weight: bold;
            }
            
            .mobile-control-section[data-section="end-game"] button:hover {
                background: #ff4444 !important;
            }
        }

        /* Desktop Layout - ensure normal layout is preserved */
        @media (min-width: 769px) {
            /* Hide mobile layout on desktop */
            .mobile-layout {
                display: none !important;
            }
            
            /* Show desktop layout */
            .desktop-layout {
                display: flex !important;
                flex-direction: column;
                gap: 8px;
                width: 100%;
            }
        }

        #ui-right-panel {
            display: flex;
            flex-direction: column;
            align-items: stretch;
            gap: 8px;
            width: 100%;
            pointer-events: auto;
        }        #live-stats {
            background: rgba(30,34,44,0.95);
            border-radius: 8px;
            box-shadow: 0 2px 16px #0008;
            color: #fff;
            padding: 8px 16px;
            font-size: 1em;
            margin: 0;
            pointer-events: auto;
            width: 100%;
        }        #tower-select {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            pointer-events: auto;
            width: 100%;
        }        #start-btn, #end-btn, #next-wave-btn {
            background: #4e6fae;
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 0.8em;
            padding: 6px 12px;
            margin: 2px 0;
            cursor: pointer;
            transition: background 0.2s;
            pointer-events: auto;
            width: 100%;
            text-align: center;
        }
        #start-btn:hover, #end-btn:hover, #next-wave-btn:hover {
            background: #6e8fde;
        }        #end-btn {
            background: #de6e6e;
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 0.9em;
            padding: 6px 12px;
            margin: 2px 0;
            cursor: pointer;
            transition: background 0.2s;
            pointer-events: auto;
            width: 100%;
            text-align: center;
        }
        #end-btn:hover {
            background: #ff4444;
        }        #stats-panel {
            position: absolute;
            right: 0; top: 0;
            min-width: 220px;
        }        #boost-btn {
            background: #6ede8a;
            color: white;
            border: none;
            border-radius: 6px;
            padding: 6px 12px;
            margin: 2px 0;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.8em;
            font-weight: bold;
            width: 100%;
            text-align: center;
        }
        #boost-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #boost-btn:hover:not(:disabled) {
            background: #8eeda6;
        }        #message-container {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }
        .game-message {
            padding: 10px 20px;
            background: rgba(0,0,0,0.7);
            color: white;
            border-radius: 8px;
            font-size: 1.2em;
            transition: opacity 0.5s;
        }
        
        /* Shop Styles */        #shop-btn {
            background: #9e6ede;
            border: none;
            border-radius: 6px;
            color: #fff;
            font-size: 0.8em;
            padding: 6px 12px;
            margin: 2px 0;
            cursor: pointer;
            transition: background 0.2s;
            pointer-events: auto;
            width: 100%;
            text-align: center;
        }
        #shop-btn:hover {
            background: #b68ef2;
        }
        #shop-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #23273a;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            padding: 20px;
            z-index: 1000;
            width: 450px;
            max-height: 80vh;
            overflow-y: auto;
            display: none;
        }
        #shop-modal-title {
            color: white;
            font-size: 1.5em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 1px solid #3b405a;
        }
        .shop-close {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 24px;
            color: white;
            cursor: pointer;
            background: none;
            border: none;
        }
        .shop-tower-item {
            background: #2e3450;
            border-radius: 8px;
            margin-bottom: 15px;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
        }
        .shop-tower-info {
            flex-grow: 1;
        }
        .shop-tower-name {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        .shop-tower-stats {
            font-size: 0.9em;
            color: #ccc;
        }
        .shop-tower-price {
            background: #4e6fae;
            border: none;
            border-radius: 6px;
            color: white;
            padding: 8px 15px;
            cursor: pointer;
            transition: all 0.2s;
            font-weight: bold;
        }
        .shop-tower-price:hover:not(:disabled) {
            background: #6e8fde;
        }
        .shop-tower-price:disabled {
            background: #555;
            cursor: not-allowed;
        }
        .shop-tower-purchased {
            background: #6ede8a;
            border: none;
            border-radius: 6px;
            color: white;
            padding: 8px 15px;
            cursor: default;
        }
        .tower-preview {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            margin-right: 15px;
        }
        
        /* Bomb UI styles */        #bomb-ui {
            background: rgba(30,34,44,0.95);
            border-radius: 8px;
            box-shadow: 0 2px 16px #0008;
            color: #fff;
            padding: 8px 16px;
            margin: 4px 0;
            display: flex;
            align-items: center;
            justify-content: space-between;
            pointer-events: auto;
            width: 100%;
        }
        
        #bomb-count {
            font-size: 1em; /* Smaller font */
            font-weight: bold;
            margin-right: 8px;
        }
        
        #place-bomb-btn {
            background: #ff3300;
            border: none;
            border-radius: 6px;
            color: #fff;
            padding: 4px 12px; /* Reduced padding */
            cursor: pointer;
            transition: background 0.2s;
            font-size: 0.8em; /* Smaller font */
        }
        
        #place-bomb-btn:hover:not(:disabled) {
            background: #ff5500;
        }
        
        #place-bomb-btn:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .shop-bomb-item {
            background: #472a24;
            border-radius: 8px;
            margin-bottom: 15px;
            margin-top: 20px;
            padding: 10px 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
        }
        
        .bomb-preview {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: #ff3300;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
        }
        
        /* Add new styles for elements */
        .element-icon {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 5px;
            text-align: center;
            font-size: 12px;
            line-height: 20px;
            vertical-align: middle;
        }
        
        /* Element tooltips */
        .element-tooltip {
            position: absolute;
            background: rgba(30,34,44,0.95);
            border-radius: 8px;
            padding: 10px;
            color: white;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 12px;
            max-width: 200px;
        }
        
        /* Wave Info Panel Styles */        #wave-info-panel {
            background: rgba(30,34,44,0.95);
            border-radius: 8px;
            box-shadow: 0 2px 16px #0008;
            color: #fff;
            padding: 8px 16px;
            margin: 4px 0;
            pointer-events: auto;
            width: 100%;
        }
        
        #wave-info-title {
            font-size: 1em; /* Smaller font */
            font-weight: bold;
            margin-bottom: 6px; /* Reduced margin */
            text-align: center;
            border-bottom: 1px solid #3b405a;
            padding-bottom: 4px; /* Reduced padding */
        }
        
        .wave-info-item {
            display: flex;
            align-items: center;
            margin: 4px 0; /* Reduced margin */
            padding: 3px 6px; /* Reduced padding */
            border-radius: 4px;
            transition: background 0.2s;
        }
        
        .wave-info-item.current {
            background: rgba(110, 143, 222, 0.3);
            border: 1px solid #6e8fde;
        }
        
        .wave-info-number {
            font-weight: bold;
            margin-right: 6px;
            min-width: 20px;
            font-size: 0.9em; /* Smaller font */
        }
        
        .wave-info-icon {
            margin-right: 6px;
            font-size: 12px; /* Smaller icon */
        }
        
        .wave-info-name {
            font-size: 0.8em; /* Smaller font */
        }        /* Make tower buttons more compact for two columns */        .tower-btn {
            border-radius: 6px;
            color: #fff;
            padding: 4px 8px;
            margin: 0;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.7em;
            width: 100%;
            height: 50px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            line-height: 1.1;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
            border: 2px solid rgba(255,255,255,0.3);
            box-shadow: inset 0 1px 3px rgba(255,255,255,0.2);
        }
        
        .tower-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3), inset 0 1px 3px rgba(255,255,255,0.3);
        }
        
        .tower-btn.selected {
            border: 2px solid #ffd700;
            box-shadow: 0 0 10px rgba(255,215,0,0.5), inset 0 1px 3px rgba(255,255,255,0.3);
        }        /* Create a button container for two-column layout */
        .button-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            width: 100%;
            pointer-events: auto;
        }
        
        /* Desktop tower select container */
        #tower-select {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            width: 100%;
        }
        
        /* Tower tooltip styles */
        #tower-tooltip {
            position: absolute;
            background: rgba(30,34,44,0.98);
            border-radius: 8px;
            padding: 12px;
            color: white;
            z-index: 1000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            font-size: 12px;
            max-width: 250px;
            border: 1px solid #4e6fae;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        }
        
        #tower-tooltip .tooltip-title {
            font-size: 14px;
            font-weight: bold;
            margin-bottom: 5px;
            color: #6e8fde;
        }
        
        #tower-tooltip .tooltip-stats {
            margin-bottom: 8px;
            line-height: 1.3;
        }
        
        #tower-tooltip .tooltip-description {
            font-style: italic;
            margin-bottom: 5px;
            color: #ccc;
        }
        
        #tower-tooltip .tooltip-tips {
            color: #88dd88;
            font-size: 11px;
        }
    </style>
</head>
<body>    <div id="game-wrapper">
        <div id="game-canvas-container">
            <!-- PixiJS Canvas will be inserted here -->
            <div id="message-container"></div>
        </div>        <div id="game-ui">
            <!-- Desktop Layout (unchanged) -->
            <div class="desktop-layout" id="ui-right-panel">                <div class="ui-panel" id="live-stats">
                    <span>Wave: <span id="wave-num">1</span></span> |
                    <span>Gold: <span id="gold">500</span></span><br>
                    <span>Lives: <span id="lives">20</span></span> |
                    <span>Left: <span id="enemies-left">0</span></span><br>
                    <span>v<span id="version">0.1.0</span></span>
                </div>
                
                <!-- Wave Information Panel -->
                <div id="wave-info-panel">
                    <div id="wave-info-title">Next Waves</div>
                    <div id="wave-info-content"></div>
                </div>
                
                <!-- Bomb UI section -->
                <div id="bomb-ui">
                    <div id="bomb-count">Bombs: 0</div>
                    <button id="place-bomb-btn" disabled>Place [X]</button>
                </div>
                
                <div class="ui-panel" id="tower-select"></div>
                
                <!-- Button container for two-column layout -->
                <div class="button-container">
                    <button id="boost-btn">Boost [B]</button>
                    <button id="shop-btn">Shop [P]</button>
                    <button id="start-btn">Start Wave</button>
                    <button id="next-wave-btn" style="display:none;">Next Wave</button>
                </div>
                
                <button id="end-btn" style="display:none;">End Game</button>
            </div>
            
            <!-- Mobile Layout -->
            <div class="mobile-layout">
                <!-- Left side - Towers -->
                <div class="towers-mobile-section">
                    <div class="towers-mobile-title">Towers</div>
                    <div class="towers-mobile-content">
                        <div class="ui-panel" id="tower-select-mobile"></div>
                    </div>
                </div>                <!-- Right side - Controls Grid -->
                <div class="controls-mobile-grid">
                    <!-- Row 1, Column 1 - Stats -->
                    <div class="mobile-control-section" data-section="stats">
                        <div class="mobile-control-title">Stats</div>
                        <div class="ui-panel" id="live-stats-mobile">
                            <span>Wave: <span id="wave-num-mobile">1</span></span><br>
                            <span>Gold: <span id="gold-mobile">500</span></span><br>
                            <span>Lives: <span id="lives-mobile">20</span></span><br>
                            <span>Left: <span id="enemies-left-mobile">0</span></span>
                        </div>
                    </div>
                    
                    <!-- Row 1, Column 2 - Wave Control -->
                    <div class="mobile-control-section" data-section="wave-control">
                        <div class="mobile-control-title">Wave</div>
                        <button id="start-btn-mobile">Start Wave</button>
                        <button id="next-wave-btn-mobile" style="display:none;">Next Wave</button>
                    </div>
                    
                    <!-- Row 2, Column 1 - Boost -->
                    <div class="mobile-control-section" data-section="boost">
                        <div class="mobile-control-title">Boost</div>
                        <button id="boost-btn-mobile">Boost [B]</button>
                    </div>
                    
                    <!-- Row 2, Column 2 - Shop -->
                    <div class="mobile-control-section" data-section="shop">
                        <div class="mobile-control-title">Shop</div>
                        <button id="shop-btn-mobile">Shop [P]</button>
                    </div>
                    
                    <!-- Row 3, Column 1 - Bombs -->
                    <div class="mobile-control-section" data-section="bombs">
                        <div class="mobile-control-title">Bombs</div>
                        <div id="bomb-ui-mobile">
                            <div id="bomb-count-mobile">Bombs: 0</div>
                            <button id="place-bomb-btn-mobile" disabled>Place [X]</button>
                        </div>
                    </div>
                    
                    <!-- Row 4, Column 2 - End Game (moved under bombs) -->
                    <div class="mobile-control-section" data-section="end-game">
                        <button id="end-btn-mobile" style="display:none;">End Game</button>
                    </div>
                    
                    <!-- Row 5, Column 1-2 - Next Waves (expanded at bottom) -->
                    <div class="mobile-control-section" data-section="next-waves">
                        <div class="mobile-control-title">NEXT WAVES</div>
                        <div id="wave-info-panel-mobile">
                            <div id="wave-info-content-mobile"></div>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="ui-panel" id="stats-panel" style="display:none;"></div>
        </div>
    </div>
    
    <!-- Shop Modal -->
    <div id="shop-modal">
        <h2 id="shop-modal-title">Tower Shop</h2>
        <button class="shop-close">Ã—</button>
        <div id="shop-content"></div>
    </div>
      <!-- Tower Tooltip -->
    <div id="tower-tooltip"></div>
    
    <script>
// --- Safari iOS Viewport Fix ---
function handleSafariViewport() {
    // Fix for Safari on iOS viewport issues
    if (/iPad|iPhone|iPod/.test(navigator.userAgent)) {
        const setVH = () => {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);
            
            // Force canvas resize on orientation change
            if (typeof resizeCanvas === 'function') {
                setTimeout(() => {
                    resizeCanvas();
                }, 200);
            }
        };
        
        setVH();
        window.addEventListener('resize', setVH);
        window.addEventListener('orientationchange', () => {
            // Multiple timeouts to handle iOS Safari's delayed viewport updates
            setTimeout(setVH, 100);
            setTimeout(setVH, 300);
            setTimeout(setVH, 500);
        });
        
        // Prevent iOS Safari from bouncing when scrolling
        document.body.addEventListener('touchmove', (e) => {
            if (e.touches.length > 1) {
                e.preventDefault();
            }
        }, { passive: false });
        
        // Hide Safari UI on scroll for better immersion
        let lastScrollTop = 0;
        const hideAddressBar = () => {
            if (window.scrollY > lastScrollTop && window.scrollY > 60) {
                window.scrollTo(0, 1);
            }
            lastScrollTop = window.scrollY;
        };
        
        window.addEventListener('scroll', hideAddressBar, { passive: true });
        
        // Initial hide attempt
        setTimeout(() => window.scrollTo(0, 1), 100);
    }
}

// Call the Safari fix immediately
handleSafariViewport();

// --- Load Game Configuration ---
let CONFIG; // Will hold the loaded configuration
let VERSION; // Game version from configuration
let GRID_SIZE;
let TILE_SIZE;
let MAP_WIDTH;
let MAP_HEIGHT;
let TOWER_TYPES;
let ENEMY_TYPES;
let BOSS_TYPE;
let ITEM_TYPES;
let BOOST_CONFIG;
let SHOP_TOWERS; // Variable for shop towers
let BOMB_CONFIG; // New variable for bomb configuration
let ELEMENTS; // New variable for element definitions
let SLOW_CONFIG; // Configuration for slow tower slow effect
let WAVE_PATTERNS; // Wave pattern configuration

// Add purchased towers tracking
let purchasedTowers = [];
let bombCount = 0; // Track number of bombs
let placingBomb = false; // Flag for bomb placement mode

async function loadConfig() {
    try {
        const response = await fetch('game-config.json');
        if (!response.ok) {
            throw new Error(`Failed to load configuration: ${response.status}`);
        }
          CONFIG = await response.json();
        
        // Set all configuration variables
        VERSION = CONFIG.gameSettings.version;
        GRID_SIZE = CONFIG.gameSettings.gridSize;
        TILE_SIZE = CONFIG.gameSettings.tileSize;
        MAP_WIDTH = GRID_SIZE * TILE_SIZE;
        MAP_HEIGHT = GRID_SIZE * TILE_SIZE;
        
        // Load elements
        ELEMENTS = CONFIG.elements || {};
        
        // Load slow tower configuration (renamed from frost)
        SLOW_CONFIG = {
            slowAmount: CONFIG.slowTower.slowAmount,
            slowDuration: CONFIG.slowTower.slowDuration,
            effectColor: parseInt(CONFIG.slowTower.effectColor)
        };
        
        // Load wave patterns
        WAVE_PATTERNS = CONFIG.wavePatterns;
        
        // Load ONLY base towers initially - no purchased towers on page load
        TOWER_TYPES = CONFIG.towers.map(tower => ({
            name: tower.name,
            key: tower.key,
            color: parseInt(tower.color),
            cost: tower.cost,
            range: tower.range,
            fireRate: tower.fireRate,
            damage: tower.damage,
            damageVariation: tower.damageVariation,
            critChance: tower.critChance,
            critMultiplier: tower.critMultiplier,
            element: tower.element || "physical",
            splashRadius: tower.splashRadius || 0,
            splashDamageRatio: tower.splashDamageRatio || 0
        }));
        
        // Load shop towers
        SHOP_TOWERS = CONFIG.shopTowers.map(tower => ({
            name: tower.name,
            key: tower.key,
            color: parseInt(tower.color),
            cost: tower.cost,
            range: tower.range,
            fireRate: tower.fireRate,
            damage: tower.damage,
            damageVariation: tower.damageVariation,
            critChance: tower.critChance,
            critMultiplier: tower.critMultiplier,
            shopPrice: tower.shopPrice,
            element: tower.element || "physical",
            flyingOnly: tower.flyingOnly || false,
            splashRadius: tower.splashRadius || 0,
            splashDamageRatio: tower.splashDamageRatio || 0
        }));
        
        // Load bomb configuration
        BOMB_CONFIG = {
            name: CONFIG.bomb.name,
            shopPrice: CONFIG.bomb.shopPrice,
            damage: CONFIG.bomb.damage,
            radius: CONFIG.bomb.radius,
            explosionDuration: CONFIG.bomb.explosionDuration,
            key: CONFIG.bomb.key,
            color: parseInt(CONFIG.bomb.color)
        };
        
        // Initialize purchased towers as empty - don't load from localStorage automatically
        purchasedTowers = [];
        
        // Load enemy types and boss type - THIS WAS MISSING!
        ENEMY_TYPES = CONFIG.enemies.map(enemy => ({
            name: enemy.name,
            baseSpeed: enemy.baseSpeed,
            baseHp: enemy.baseHp,
            reward: enemy.reward,
            color: parseInt(enemy.color),
            flying: !!enemy.flying,
            waveScaling: enemy.waveScaling,
            element: enemy.element || "physical",
            emoji: enemy.emoji || "",
            elementalProperties: enemy.elementalProperties || { weaknesses: {}, resistances: {} }
        }));
        
        BOSS_TYPE = {
            name: CONFIG.boss.name,
            baseSpeed: CONFIG.boss.baseSpeed,
            baseHp: CONFIG.boss.baseHp,
            reward: CONFIG.boss.reward,
            color: parseInt(CONFIG.boss.color),
            waveScaling: CONFIG.boss.waveScaling,
            element: CONFIG.boss.element || "physical",
            emoji: CONFIG.boss.emoji || "",
            elementalProperties: CONFIG.boss.elementalProperties || { weaknesses: {}, resistances: {} }
        };
        
        ITEM_TYPES = CONFIG.items;
        BOOST_CONFIG = CONFIG.boost;
        
        // Initialize the game
        initGame();
        
    } catch (error) {
        console.error("Error loading configuration:", error);
        alert("Failed to load game configuration! Check the console for details.");
    }
}

// --- Game State Variables ---
let towers = [];
let enemies = [];
let projectiles = [];
let damageNumbers = [];
let items = []; 
let activeEffects = [];
let explosions = []; // Track active explosions
let splashEffects = []; // Track splash animations
let gold;
let wave;
let lives;
let placingTower = null;
let selectedTowerType = -1;
let selectedEnemy = null; // Track selected enemy
let isGameRunning = false;
let pathGrid = [];
let startTile;
let endTile;
let flyingBypass = true;
let towerStatsWindow = null;
let boostActive = false;
let boostCooldown = 0;
let damageTextPool = []; // Pool of reusable text objects for damage numbers
let enemySpawnQueue = []; // Queue for enemies to spawn
let spawningWave = false;

// --- Function to apply slow effect from Slow Tower ---
function applySlowEffect(enemy, tower) {
    // Apply slowing effect if the tower is a Slow Tower
    if (tower.type.name === "Slow") {
        // If the enemy is not already slowed, apply slow effect
        if (!enemy.slowed) {
            // Store the true original speed before any slow is applied
            const trueOriginalSpeed = enemy.speed;
            
            // Set the slowed status on the enemy
            enemy.slowed = {
                amount: SLOW_CONFIG.slowAmount,
                duration: SLOW_CONFIG.slowDuration * 60, // Convert to frames
                originalSpeed: trueOriginalSpeed, // Store original speed
                effectColor: SLOW_CONFIG.effectColor
            };
            
            // Apply the slow effect immediately
            enemy.speed = enemy.slowed.originalSpeed * (1 - enemy.slowed.amount);
        } else {
            // Enemy already slowed - just refresh the duration, don't stack the effect
            enemy.slowed.duration = SLOW_CONFIG.slowDuration * 60;
        }
    }
}

// --- PixiJS Setup ---
const app = new PIXI.Application({
    backgroundColor: 0x23273a,
    antialias: true
});
document.getElementById('game-canvas-container').appendChild(app.view);

// Canvas resize function for orientation changes
function resizeCanvas() {
    if (!app || !app.renderer) return;
    
    // Get current container dimensions
    const container = document.getElementById('game-canvas-container');
    const containerRect = container.getBoundingClientRect();
    
    // Use the container dimensions to maintain aspect ratio
    const containerWidth = containerRect.width;
    const containerHeight = containerRect.height;
    
    // Calculate the best fit while maintaining aspect ratio
    const gameAspectRatio = MAP_WIDTH / MAP_HEIGHT;
    const containerAspectRatio = containerWidth / containerHeight;
    
    let newWidth, newHeight;
    
    if (containerAspectRatio > gameAspectRatio) {
        // Container is wider than needed, fit to height
        newHeight = containerHeight;
        newWidth = newHeight * gameAspectRatio;
    } else {
        // Container is taller than needed, fit to width
        newWidth = containerWidth;
        newHeight = newWidth / gameAspectRatio;
    }
    
    // Ensure minimum size to keep the game playable
    newWidth = Math.max(newWidth, 300);
    newHeight = Math.max(newHeight, 300);
    
    // Update canvas display size
    app.view.style.width = newWidth + 'px';
    app.view.style.height = newHeight + 'px';
    
    // Keep the internal renderer size the same for consistent game logic
    // Only the display scaling changes
}

function initGame() {
    // Set canvas dimensions from configuration
    app.renderer.resize(MAP_WIDTH, MAP_HEIGHT);
    app.view.style.display = 'block';
    
    // Initial canvas resize
    resizeCanvas();
    
    // Initialize game state
    gold = CONFIG.gameSettings.startingGold;
    lives = CONFIG.gameSettings.startingLives;
    wave = 1;
    startTile = {x: 0, y: Math.floor(GRID_SIZE/2)};
    endTile = {x: GRID_SIZE-1, y: Math.floor(GRID_SIZE/2)};
    
    // Initialize text object pool for damage numbers
    createTextPool();
    
    // Apply UI updates
    updateUI();
    renderTowerSelect();
    renderWaveInfo(); // Add wave info rendering
    updatePathGrid();
    
    // Set up all game event handlers and logic
    setupGameHandlers();
}

// Create a pool of reusable text objects for damage numbers
function createTextPool() {
    // Clean up any existing pool
    damageTextPool.forEach(text => {
        if (app.stage.children.includes(text)) {
            app.stage.removeChild(text);
        }
    });
    
    damageTextPool = [];
    
    // Create pool of text objects (adjust pool size based on expected max concurrent numbers)
    const poolSize = 50;
    for (let i = 0; i < poolSize; i++) {
        const text = new PIXI.Text('', {
            fontFamily: "Arial",
            fontSize: 14,
            fill: 0xFFFFFF,
            align: "center",
            fontWeight: "bold",
            strokeThickness: 3,
            stroke: 0x000000
        });
        text.visible = false;
        text.anchor.set(0.5);
        app.stage.addChild(text);
        damageTextPool.push(text);
    }
}

// --- Shop Functions ---
function loadPurchasedTowers() {
    const saved = localStorage.getItem('purchasedTowers');
    if (saved) {
        try {
            purchasedTowers = JSON.parse(saved);
            
            // Add purchased towers to TOWER_TYPES
            purchasedTowers.forEach(towerName => {
                const shopTower = SHOP_TOWERS.find(t => t.name === towerName);
                if (shopTower && !TOWER_TYPES.some(t => t.name === towerName)) {
                    TOWER_TYPES.push({...shopTower});
                }
            });
        } catch (e) {
            console.error("Error loading purchased towers:", e);
            purchasedTowers = [];
        }
    } else {
        purchasedTowers = [];
    }
}

function savePurchasedTowers() {
    localStorage.setItem('purchasedTowers', JSON.stringify(purchasedTowers));
}

function purchaseTower(towerName) {
    const tower = SHOP_TOWERS.find(t => t.name === towerName);
    if (!tower) return false;
    
    if (gold >= tower.shopPrice) {
        gold -= tower.shopPrice;
        purchasedTowers.push(tower.name);
        
        // Add to available towers
        if (!TOWER_TYPES.some(t => t.name === tower.name)) {
            TOWER_TYPES.push({...tower});
        }
        
        savePurchasedTowers();
        updateUI();
        renderTowerSelect();
        renderShop(); // Update shop to show purchased status
        
        showMessage(`Purchased ${tower.name} Tower!`, "#6ede8a");
        return true;
    } else {
        showMessage(`Not enough gold to buy ${tower.name} Tower!`, "#ff6666");
        return false;
    }
}

function buyBomb() {
    if (gold >= BOMB_CONFIG.shopPrice) {
        gold -= BOMB_CONFIG.shopPrice;
        bombCount++;
        updateUI();
        renderShop(); // Update shop UI
        
        showMessage(`Purchased a ${BOMB_CONFIG.name}!`, "#ff5500");
        return true;
    } else {
        showMessage(`Not enough gold to buy a bomb!`, "#ff6666");
        return false;
    }
}

function renderShop() {
    const shopContent = document.getElementById('shop-content');
    shopContent.innerHTML = '';
    
    // First add the bomb item to the shop
    const bombItem = document.createElement('div');
    bombItem.className = 'shop-bomb-item';
    
    // Bomb preview icon
    const bombPreview = document.createElement('div');
    bombPreview.className = 'bomb-preview';
    bombPreview.textContent = 'ðŸ’£';
    
    const infoDiv = document.createElement('div');
    infoDiv.className = 'shop-tower-info';
    
    const nameDiv = document.createElement('div');
    nameDiv.className = 'shop-tower-name';
    nameDiv.textContent = `${BOMB_CONFIG.name} [${BOMB_CONFIG.key}]`;
    
    const statsDiv = document.createElement('div');
    statsDiv.className = 'shop-tower-stats';
    statsDiv.innerHTML = `
        Damage: Up to ${BOMB_CONFIG.damage} | Radius: ${BOMB_CONFIG.radius}px<br>
        You have: ${bombCount} bombs
    `;
    
    const buyButton = document.createElement('button');
    buyButton.className = 'shop-tower-price';
    buyButton.textContent = `Buy: ${BOMB_CONFIG.shopPrice} Gold`;
    buyButton.disabled = gold < BOMB_CONFIG.shopPrice;
    buyButton.onclick = buyBomb;
    
    infoDiv.appendChild(nameDiv);
    infoDiv.appendChild(statsDiv);
    
    bombItem.appendChild(bombPreview);
    bombItem.appendChild(infoDiv);
    bombItem.appendChild(buyButton);
    
    shopContent.appendChild(bombItem);
    
    // Add tower items after the bomb
    SHOP_TOWERS.forEach(tower => {
        const isPurchased = purchasedTowers.includes(tower.name);
        
        const towerItem = document.createElement('div');
        towerItem.className = 'shop-tower-item';
        
        // Tower preview circle with color
        const towerPreview = document.createElement('div');
        towerPreview.className = 'tower-preview';
        towerPreview.style.background = '#' + tower.color.toString(16).padStart(6, '0');
        
        // Add element emoji if available
        const elementInfo = ELEMENTS[tower.element] || {};
        if (elementInfo.emoji) {
            towerPreview.textContent = elementInfo.emoji;
        }
        
        const infoDiv = document.createElement('div');
        infoDiv.className = 'shop-tower-info';
        
        const nameDiv = document.createElement('div');
        nameDiv.className = 'shop-tower-name';
        nameDiv.textContent = `${tower.name} Tower [${tower.key}]`;
        
        // Enhanced stats display with same format as tooltips
        const statsDiv = document.createElement('div');
        statsDiv.className = 'shop-tower-stats';
        
        // Calculate detailed stats (same as tooltip)
        const baseDamage = tower.damage;
        const variation = tower.damageVariation;
        const minDamage = Math.floor(baseDamage * (1 - variation));
        const maxDamage = Math.ceil(baseDamage * (1 + variation));
        const critChance = tower.critChance * 100;
        const damagePerSec = baseDamage / tower.fireRate;
        
        // Get element info for detailed stats (renamed to avoid conflict)
        const detailedElementInfo = ELEMENTS[tower.element] || { name: "Physical", color: "0xcccccc" };
        const elementName = detailedElementInfo.name;
        const elementEmoji = detailedElementInfo.emoji || "";
        
        // Build element text
        let elementText = "";
        if (tower.element && tower.element !== "physical") {
            elementText = `<span class="element-icon" style="background: #${tower.color.toString(16).padStart(6, '0')}">${elementEmoji}</span> ${elementName}<br>`;
        }
        
        // Build special abilities text
        let specialText = "";
        if (tower.name === "Slow") {
            specialText = `<strong>Slow:</strong> ${SLOW_CONFIG.slowAmount * 100}% for ${SLOW_CONFIG.slowDuration}s<br>`;
        }
        if (tower.flyingOnly) {
            specialText = `<strong>Special:</strong> Only targets flying enemies<br>`;
        }
        if (tower.splashRadius > 0) {
            specialText = `<strong>Splash:</strong> ${(tower.splashDamageRatio * 100).toFixed(0)}% damage, ${tower.splashRadius}px radius<br>`;
        }
        
        // Get config tower for description and tips
        const configTower = CONFIG.shopTowers.find(ct => ct.name === tower.name);
        
        statsDiv.innerHTML = `
            <div style="font-style: italic; color: #aaa; margin-bottom: 5px;">${configTower && configTower.description ? configTower.description : ''}</div>
            ${elementText}
            <strong>Damage:</strong> ${minDamage}-${maxDamage} | <strong>DPS:</strong> ${damagePerSec.toFixed(1)}<br>
            <strong>Range:</strong> ${tower.range} | <strong>Crit:</strong> ${critChance.toFixed(0)}%<br>
            ${specialText}
            <div style="color: #88dd88; font-size: 11px; margin-top: 3px;"><strong>Tips:</strong> ${configTower && configTower.tips ? configTower.tips : ''}</div>
        `;
        
        const priceButton = document.createElement('button');
        if (isPurchased) {
            priceButton.className = 'shop-tower-purchased';
            priceButton.textContent = 'Purchased';
        } else {
            priceButton.className = 'shop-tower-price';
            priceButton.textContent = `Buy: ${tower.shopPrice} Gold`;
            priceButton.disabled = gold < tower.shopPrice;
            priceButton.onclick = () => purchaseTower(tower.name);
        }
        
        infoDiv.appendChild(nameDiv);
        infoDiv.appendChild(statsDiv);
        
        towerItem.appendChild(towerPreview);
        towerItem.appendChild(infoDiv);
        towerItem.appendChild(priceButton);
        
        shopContent.appendChild(towerItem);
    });
}

// --- UI Setup ---
const towerSelect = document.getElementById('tower-select');
const wavePanel = document.getElementById('wave-panel');
const statsPanel = document.getElementById('stats-panel');
const waveNum = document.getElementById('wave-num');
const goldSpan = document.getElementById('gold');
const startBtn = document.getElementById('start-btn');
const endBtn = document.getElementById('end-btn');
const nextWaveBtn = document.getElementById('next-wave-btn');
const boostBtn = document.getElementById('boost-btn');
const shopBtn = document.getElementById('shop-btn');
const shopModal = document.getElementById('shop-modal');
const shopCloseBtn = document.querySelector('.shop-close');
const messageContainer = document.getElementById('message-container');

// Mobile UI elements
const waveNumMobile = document.getElementById('wave-num-mobile');
const goldSpanMobile = document.getElementById('gold-mobile');
const startBtnMobile = document.getElementById('start-btn-mobile');
const endBtnMobile = document.getElementById('end-btn-mobile');
const nextWaveBtnMobile = document.getElementById('next-wave-btn-mobile');
const boostBtnMobile = document.getElementById('boost-btn-mobile');
const shopBtnMobile = document.getElementById('shop-btn-mobile');

function updateUI() {
    // Update desktop UI
    waveNum.textContent = wave;
    goldSpan.textContent = gold;
    document.getElementById('lives').textContent = lives;
    document.getElementById('enemies-left').textContent = enemies.filter(e => e.alive).length;
    document.getElementById('bomb-count').textContent = `Bombs: ${bombCount}`;
    
    // Update mobile UI
    if (waveNumMobile) waveNumMobile.textContent = wave;
    if (goldSpanMobile) goldSpanMobile.textContent = gold;
    const livesMobile = document.getElementById('lives-mobile');
    const enemiesLeftMobile = document.getElementById('enemies-left-mobile');
    const bombCountMobile = document.getElementById('bomb-count-mobile');
    if (livesMobile) livesMobile.textContent = lives;
    if (enemiesLeftMobile) enemiesLeftMobile.textContent = enemies.filter(e => e.alive).length;
    if (bombCountMobile) bombCountMobile.textContent = `Bombs: ${bombCount}`;
    
    // Update bomb button state (desktop)
    const bombBtn = document.getElementById('place-bomb-btn');
    bombBtn.disabled = bombCount <= 0;
    
    // Update bomb button state (mobile)
    const bombBtnMobile = document.getElementById('place-bomb-btn-mobile');
    if (bombBtnMobile) bombBtnMobile.disabled = bombCount <= 0;
    
    // Update bomb button text and style
    const updateBombButton = (btn) => {
        if (!btn) return;
        if (placingBomb) {
            btn.textContent = 'Cancel [X]';
            btn.style.background = '#666';
        } else {
            btn.textContent = 'Place [X]';
            btn.style.background = btn.disabled ? '#666' : '#ff3300';
        }
    };
    
    updateBombButton(bombBtn);
    updateBombButton(bombBtnMobile);
    
    // Update boost buttons
    const updateBoostButton = (btn) => {
        if (!btn) return;
        if (boostActive) {
            btn.textContent = 'Boosting...';
            btn.disabled = true;
        } else if (boostCooldown > 0) {
            btn.textContent = `Boost [${Math.ceil(boostCooldown)}s]`;
            btn.disabled = true;
        } else {
            btn.textContent = 'Boost [B]';
            btn.disabled = false;
        }
    };
      updateBoostButton(boostBtn);
    updateBoostButton(boostBtnMobile);
    
    // Update shop button price indicators
    const numAvailable = SHOP_TOWERS.filter(t => 
        !purchasedTowers.includes(t.name) && gold >= t.shopPrice
    ).length;
    
    if (numAvailable > 0) {
        shopBtn.textContent = `Shop [P] (${numAvailable} available)`;
    } else {
        shopBtn.textContent = 'Shop [P]';
    }
    
    // Only update wave info when wave changes - removed automatic call
    // renderWaveInfo();
}

function showMessage(text, color = "#ffffff") {
    const message = document.createElement('div');
    message.className = 'game-message';
    message.textContent = text;
    message.style.color = color;
    
    messageContainer.appendChild(message);
    
    // Remove after 3 seconds
    setTimeout(() => {
        message.style.opacity = '0';
        setTimeout(() => {
            if (messageContainer.contains(message)) {
                messageContainer.removeChild(message);
            }
        }, 500);
    }, 3000);
}

function showStats(enemy) {
    statsPanel.style.display = 'block';
    
    // Get element info
    const elementInfo = ELEMENTS[enemy.type.element] || { name: "Physical", color: "0xcccccc" };
    const elementName = elementInfo.name;
    const elementColor = '#' + elementInfo.color.toString(16).padStart(6, '0');
    const elementEmoji = elementInfo.emoji || "";
    
    // Build weaknesses and resistances text
    let weaknessesText = "";
    let resistancesText = "";
    
    if (enemy.type.elementalProperties) {
        if (enemy.type.elementalProperties.weaknesses && Object.keys(enemy.type.elementalProperties.weaknesses).length > 0) {
            weaknessesText = "Weak against: " + Object.entries(enemy.type.elementalProperties.weaknesses)
                .map(([element, value]) => {
                    const info = ELEMENTS[element] || { name: element };
                    return `${info.emoji || ""} ${info.name || element} (${(100 * (1 - value)).toFixed(0)}%)`;
                }).join(", ");
        }
        
        if (enemy.type.elementalProperties.resistances && Object.keys(enemy.type.elementalProperties.resistances).length > 0) {
            resistancesText = "Resistant to: " + Object.entries(enemy.type.elementalProperties.resistances)
                .map(([element, value]) => {
                    const info = ELEMENTS[element] || { name: element };
                    return `${info.emoji || ""} ${info.name || element} (${(100 * value).toFixed(0)}%)`;
                }).join(", ");
        }
    }
    
    // Create HTML for enemy stats with white text
    statsPanel.innerHTML = `
        <div style="color: white;">
            <b>${enemy.type.name} ${elementEmoji}</b><br>
            <span class="element-icon" style="background: ${elementColor}">${elementEmoji}</span> ${elementName}<br>
            HP: ${Math.ceil(enemy.hp)}/${enemy.maxHp}<br>
            Speed: ${enemy.speed.toFixed(1)}<br>
            Reward: ${enemy.type.reward}<br>
            ${weaknessesText ? weaknessesText + "<br>" : ""}
            ${resistancesText}
        </div>
    `;
}

function hideStats() {
    statsPanel.style.display = 'none';
}

// --- Tower Selection UI ---
function renderTowerSelect() {    // Update desktop tower selection
    towerSelect.innerHTML = '';
    TOWER_TYPES.forEach((t, i) => {
        const btn = document.createElement('button');
        btn.className = 'tower-btn' + (selectedTowerType === i ? ' selected' : '');
        
        // Set background color based on tower color
        const towerColor = '#' + t.color.toString(16).padStart(6, '0');
        btn.style.background = towerColor;
        
        // Get configuration data for tooltips
        const configTower = CONFIG.towers.find(ct => ct.name === t.name) || 
                           CONFIG.shopTowers.find(st => st.name === t.name);
        
        // Condensed text layout with tighter spacing
        btn.innerHTML = `<div style="text-align: center; line-height: 1.1;">
            <div style="font-weight: bold; margin-bottom: 1px;">${t.name}</div>
            <div style="font-size: 0.85em; margin-bottom: 1px;">[${t.key}]</div>
            <div style="font-size: 0.9em;">Cost: ${t.cost}</div>
        </div>`;btn.onclick = () => {
            selectedTowerType = i;
            // Close tower stats window if one is open
            if (towerStatsWindow) {
                document.body.removeChild(towerStatsWindow);
                towerStatsWindow = null;
            }
            renderTowerSelect();
        };
        
        // Add touch support for mobile
        btn.addEventListener('touchstart', (e) => {
            e.preventDefault(); // Prevent default touch behavior
            selectedTowerType = i;
            // Close tower stats window if one is open
            if (towerStatsWindow) {
                document.body.removeChild(towerStatsWindow);
                towerStatsWindow = null;
            }
            renderTowerSelect();
        });
        
        // Add hover tooltip functionality
        btn.addEventListener('mouseenter', (e) => {
            showTowerTooltip(t, configTower, e.pageX, e.pageY);
        });
        
        btn.addEventListener('mouseleave', () => {
            hideTowerTooltip();
        });
        
        towerSelect.appendChild(btn);
    });
      // Update mobile tower selection
    const towerSelectMobile = document.getElementById('tower-select-mobile');
    if (towerSelectMobile) {
        towerSelectMobile.innerHTML = '';
        TOWER_TYPES.forEach((t, i) => {
            const btn = document.createElement('button');
            btn.className = 'tower-btn' + (selectedTowerType === i ? ' selected' : '');
            
            // Set background color based on tower color
            const towerColor = '#' + t.color.toString(16).padStart(6, '0');
            btn.style.background = towerColor;
            
            // Condensed text layout for mobile
            btn.innerHTML = `<div style="text-align: center; line-height: 1;">
                <div style="font-weight: bold; font-size: 0.7em;">${t.name}</div>
                <div style="font-size: 0.6em;">[${t.key}] ${t.cost}g</div>
            </div>`;
            
            btn.onclick = () => {
                selectedTowerType = i;
                // Close tower stats window if one is open
                if (towerStatsWindow) {
                    document.body.removeChild(towerStatsWindow);
                    towerStatsWindow = null;
                }
                renderTowerSelect();
            };
            
            // Add touch support for mobile
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent default touch behavior
                selectedTowerType = i;
                // Close tower stats window if one is open
                if (towerStatsWindow) {
                    document.body.removeChild(towerStatsWindow);
                    towerStatsWindow = null;
                }
                renderTowerSelect();
            });
            
            towerSelectMobile.appendChild(btn);
        });
    }
}

// --- Tower Tooltip Functions ---
function showTowerTooltip(tower, configTower, x, y) {
    const tooltip = document.getElementById('tower-tooltip');
    
    // Calculate detailed stats
    const baseDamage = tower.damage;
    const variation = tower.damageVariation;
    const minDamage = Math.floor(baseDamage * (1 - variation));
    const maxDamage = Math.ceil(baseDamage * (1 + variation));
    const critChance = tower.critChance * 100;
    const damagePerSec = baseDamage / tower.fireRate;
    
    // Get element info
    const elementInfo = ELEMENTS[tower.element] || { name: "Physical", color: "0xcccccc" };
    const elementName = elementInfo.name;
    const elementEmoji = elementInfo.emoji || "";
    
    // Build special abilities text
    let specialText = "";
    if (tower.name === "Slow") {
        specialText = `<br><strong>Slow:</strong> ${SLOW_CONFIG.slowAmount * 100}% for ${SLOW_CONFIG.slowDuration}s`;
    }
    if (tower.flyingOnly) {
        specialText = `<br><strong>Special:</strong> Only targets flying enemies`;
    }
    if (tower.splashRadius > 0) {
        specialText = `<br><strong>Splash:</strong> ${(tower.splashDamageRatio * 100).toFixed(0)}% damage, ${tower.splashRadius}px radius`;
    }
    if (tower.name === "Melee") {
        specialText = `<br><strong>Special:</strong> Hits all nearby ground enemies`;
    }
    
    tooltip.innerHTML = `
        <div class="tooltip-title">${tower.name} Tower [${tower.key}]</div>
        <div class="tooltip-stats">
            <strong>Element:</strong> ${elementEmoji} ${elementName}<br>
            <strong>Damage:</strong> ${minDamage}-${maxDamage} | <strong>DPS:</strong> ${damagePerSec.toFixed(1)}<br>
            <strong>Range:</strong> ${tower.range} | <strong>Crit:</strong> ${critChance.toFixed(0)}%<br>
            <strong>Cost:</strong> ${tower.cost} gold${specialText}
        </div>
        ${configTower && configTower.description ? `<div class="tooltip-description">${configTower.description}</div>` : ''}
        ${configTower && configTower.tips ? `<div class="tooltip-tips">ðŸ’¡ ${configTower.tips}</div>` : ''}
    `;
    
    // Position tooltip
    tooltip.style.left = (x + 10) + 'px';
    tooltip.style.top = (y - 10) + 'px';
    tooltip.style.opacity = '1';
}

function hideTowerTooltip() {
    const tooltip = document.getElementById('tower-tooltip');
    tooltip.style.opacity = '0';
}

// --- Game Handlers ---
function setupGameHandlers() {
    // --- Boost Button Handler ---
    boostBtn.addEventListener('click', activateBoost);
    
    // --- Shop Button Handlers ---
    shopBtn.addEventListener('click', () => {
        shopModal.style.display = 'block';
        renderShop();
    });
    
    shopCloseBtn.addEventListener('click', () => {
        shopModal.style.display = 'none';
    });
    
    // Close shop when clicking outside
    window.addEventListener('click', (e) => {
        if (e.target === shopModal) {
            shopModal.style.display = 'none';
        }
    });
    
    // --- Bomb Button Handler ---
    const bombBtn = document.getElementById('place-bomb-btn');
    bombBtn.addEventListener('click', () => {
        if (bombCount <= 0) return;
        
        placingBomb = !placingBomb;
        
        // Cancel tower placement if active
        if (placingBomb) {
            selectedTowerType = -1;
            renderTowerSelect();
        }
        
        updateUI();
    });
    
    // --- Key Handlers ---
    document.addEventListener('keydown', e => {
        // Boost key
        if (e.key.toLowerCase() === BOOST_CONFIG.key.toLowerCase()) {
            if (!boostActive && boostCooldown <= 0) {
                activateBoost();
            }
            return;
        }
        
        // Shop key (P)
        if (e.key.toLowerCase() === 'p') {
            if (shopModal.style.display === 'block') {
                shopModal.style.display = 'none';
            } else {
                shopModal.style.display = 'block';
                renderShop();
            }
            return;
        }
        
        // Bomb key (X)
        if (e.key.toLowerCase() === BOMB_CONFIG.key.toLowerCase()) {
            if (bombCount > 0) {
                placingBomb = !placingBomb;
                
                // Cancel tower placement if active
                if (placingBomb) {
                    selectedTowerType = -1;
                    renderTowerSelect();
                }
                
                updateUI();
            }
            return;
        }
        
        // Tower selection via keys
        const idx = TOWER_TYPES.findIndex(t => t.key.toLowerCase() === e.key.toLowerCase());
        if (idx !== -1) {
            selectedTowerType = idx;
            renderTowerSelect();
        }
    });
      // --- Button Handlers ---
    startBtn.onclick = startWave;
    endBtn.onclick = () => {
        // Show warning before ending the game
        if (confirm("Warning: This will end your current game and you will lose all progress in this run. Are you sure you want to continue?")) {
            endGame();
        }
    };
    nextWaveBtn.onclick = nextWave;
    
    // --- Mobile Button Handlers ---
    if (startBtnMobile) {
        startBtnMobile.onclick = startWave;
        startBtnMobile.addEventListener('touchstart', (e) => {
            e.preventDefault();
            startWave();
        });
    }
    
    if (endBtnMobile) {
        endBtnMobile.onclick = () => {
            if (confirm("Warning: This will end your current game and you will lose all progress in this run. Are you sure you want to continue?")) {
                endGame();
            }
        };
        endBtnMobile.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (confirm("Warning: This will end your current game and you will lose all progress in this run. Are you sure you want to continue?")) {
                endGame();
            }
        });
    }
    
    if (nextWaveBtnMobile) {
        nextWaveBtnMobile.onclick = nextWave;
        nextWaveBtnMobile.addEventListener('touchstart', (e) => {
            e.preventDefault();
            nextWave();
        });
    }
    
    if (boostBtnMobile) {
        boostBtnMobile.addEventListener('click', activateBoost);
        boostBtnMobile.addEventListener('touchstart', (e) => {
            e.preventDefault();
            activateBoost();
        });
    }
    
    if (shopBtnMobile) {
        shopBtnMobile.addEventListener('click', () => {
            shopModal.style.display = 'block';
            renderShop();
        });
        shopBtnMobile.addEventListener('touchstart', (e) => {
            e.preventDefault();
            shopModal.style.display = 'block';
            renderShop();
        });
    }
    
    // Mobile bomb button
    const bombBtnMobile = document.getElementById('place-bomb-btn-mobile');
    if (bombBtnMobile) {
        bombBtnMobile.addEventListener('click', () => {
            if (bombCount <= 0) return;
            
            placingBomb = !placingBomb;
            
            // Cancel tower placement if active
            if (placingBomb) {
                selectedTowerType = -1;
                renderTowerSelect();
            }
            
            updateUI();
        });
        bombBtnMobile.addEventListener('touchstart', (e) => {
            e.preventDefault();
            if (bombCount <= 0) return;
            
            placingBomb = !placingBomb;
            
            // Cancel tower placement if active
            if (placingBomb) {
                selectedTowerType = -1;
                renderTowerSelect();
            }
            
            updateUI();
        });
    }
      // Set up other event handlers
    setupPlacementHandlers();
    
    // Add window resize listener for canvas resizing
    window.addEventListener('resize', () => {
        if (typeof resizeCanvas === 'function') {
            setTimeout(resizeCanvas, 100);
        }
    });
    
    // Start the game loop
    app.ticker.add(gameLoop);
}

function activateBoost() {
    if (boostActive || boostCooldown > 0) return;
    
    boostActive = true;
    showMessage("BOOST ACTIVATED!", "#6ede8a");
    updateUI();
    
    // End boost after duration
    setTimeout(() => {
        boostActive = false;
        boostCooldown = BOOST_CONFIG.cooldown;
        updateUI();
    }, BOOST_CONFIG.duration * 1000);
}

function startWave() {
    isGameRunning = true;
    startBtn.style.display = 'none';
    endBtn.style.display = '';
    
    // Update mobile buttons
    if (startBtnMobile) startBtnMobile.style.display = 'none';
    if (endBtnMobile) endBtnMobile.style.display = '';
    
    spawnWave();
}

function endGame() {
    isGameRunning = false;
    endBtn.style.display = 'none';
    startBtn.style.display = '';
    
    // Update mobile buttons
    if (endBtnMobile) endBtnMobile.style.display = 'none';
    if (startBtnMobile) startBtnMobile.style.display = '';
    
    showGameOver('Game Ended');
}

function nextWave() {
    isGameRunning = true;
    nextWaveBtn.style.display = 'none';
    
    // Update mobile buttons
    if (nextWaveBtnMobile) nextWaveBtnMobile.style.display = 'none';
    
    wave++;
    updateUI();
    renderWaveInfo(); // Only update wave info when wave actually changes
    spawnWave();
}

// --- Pathfinding ---
function createGrid() {
    let grid = [];
    for (let y = 0; y < GRID_SIZE; y++) {
        let row = [];
        for (let x = 0; x < GRID_SIZE; x++) {
            row.push({x, y, blocked: false});
        }
        grid.push(row);
    }
    return grid;
}

function updatePathGrid() {
    pathGrid = createGrid();
    towers.forEach(t => {
        pathGrid[t.y][t.x].blocked = true;
    });
}

function heuristic(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}

function neighbors(node) {
    let dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    let result = [];
    for (let d of dirs) {
        let nx = node.x + d[0], ny = node.y + d[1];
        if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && !pathGrid[ny][nx].blocked) {
            result.push(pathGrid[ny][nx]);
        }
    }
    return result;
}

function aStar(start, end) {
    let open = [pathGrid[start.y][start.x]];
    let cameFrom = new Map();
    let gScore = Array(GRID_SIZE).fill().map(()=>Array(GRID_SIZE).fill(Infinity));
    gScore[start.y][start.x] = 0;
    let fScore = Array(GRID_SIZE).fill().map(()=>Array(GRID_SIZE).fill(Infinity));
    fScore[start.y][start.x] = heuristic(start, end);
    
    while (open.length) {
        open.sort((a,b)=>fScore[a.y][a.x]-fScore[b.y][b.x]);
        let current = open.shift();
        
        if (current.x === end.x && current.y === end.y) {
            let path = [];
            let node = current;
            while (cameFrom.has(node)) {
                path.push(node);
                node = cameFrom.get(node);
            }
            path.push(pathGrid[start.y][start.x]);
            return path.reverse();
        }
        
        for (let neighbor of neighbors(current)) {
            let tentative = gScore[current.y][current.x] + 1;
            if (tentative < gScore[neighbor.y][neighbor.x]) {
                cameFrom.set(neighbor, current);
                gScore[neighbor.y][neighbor.x] = tentative;
                fScore[neighbor.y][neighbor.x] = tentative + heuristic(neighbor, end);
                if (!open.includes(neighbor)) open.push(neighbor);
            }
        }
    }
    return null;
}

// --- Tower Placement ---
let previewTile = null;
let selectedTower = null;
let mobilePreviewTile = null; // Mobile-specific preview tile
let isTouchPlacement = false; // Flag to track if we're in mobile touch placement mode

function setupPlacementHandlers() {    // Helper function to get coordinates from mouse or touch event
    function getEventCoordinates(e) {
        const rect = app.view.getBoundingClientRect();
        let clientX, clientY;
        
        if (e.touches && e.touches.length > 0) {
            // Touch event
            clientX = e.touches[0].clientX;
            clientY = e.touches[0].clientY;
        } else if (e.changedTouches && e.changedTouches.length > 0) {
            // Touch end event
            clientX = e.changedTouches[0].clientX;
            clientY = e.changedTouches[0].clientY;
        } else {
            // Mouse event
            clientX = e.clientX;
            clientY = e.clientY;
        }
        
        // Get the relative position within the canvas
        const relativeX = clientX - rect.left;
        const relativeY = clientY - rect.top;
        
        // Scale the coordinates to match the actual canvas size
        // The canvas might be scaled by CSS, so we need to convert from display size to actual size
        const scaleX = app.view.width / rect.width;
        const scaleY = app.view.height / rect.height;
        
        return {
            mx: relativeX * scaleX,
            my: relativeY * scaleY
        };
    }
      // Helper function to handle move events (mouse or touch)
    function handleMoveEvent(e) {
        const {mx, my} = getEventCoordinates(e);
        const tx = Math.floor(mx / TILE_SIZE);
        const ty = Math.floor(my / TILE_SIZE);
        
        // Only show preview if in bounds and not on start/end/tower and a tower type is selected
        if (
            selectedTowerType >= 0 && 
            tx >= 0 && tx < GRID_SIZE && ty >= 0 && ty < GRID_SIZE &&
            !(tx === startTile.x && ty === startTile.y) &&
            !(tx === endTile.x && ty === endTile.y) &&
            !towers.some(t => t.x === tx && t.y === ty)
        ) {
            if (isTouchPlacement) {
                // For mobile touch placement, use mobile preview tile
                mobilePreviewTile = {x: tx, y: ty};
            } else {
                // For desktop, use regular preview tile
                previewTile = {x: tx, y: ty};
            }
        } else {
            if (isTouchPlacement) {
                mobilePreviewTile = null;
            } else {
                previewTile = null;
            }
        }
    }
      // Helper function to handle click/tap events
    function handleClickEvent(e) {
        e.preventDefault(); // Prevent default touch behavior
        
        const {mx, my} = getEventCoordinates(e);
        const tx = Math.floor(mx / TILE_SIZE);
        const ty = Math.floor(my / TILE_SIZE);
        
        // Close any existing tower stats window
        if (towerStatsWindow) {
            document.body.removeChild(towerStatsWindow);
            towerStatsWindow = null;
        }
        
        // Check if placing bomb
        if (placingBomb) {
            placeBomb(mx, my);
            return;
        }
        
        // Check for enemy selection first (before tower selection)
        let clickedEnemy = null;
        for (let enemy of enemies) {
            if (!enemy.alive) continue;
            let r = enemy.type.name === "Boss" ? TILE_SIZE/1.7 : TILE_SIZE/2.5;
            if (Math.hypot(enemy.x - mx, enemy.y - my) < r) {
                clickedEnemy = enemy;
                break;
            }
        }
        
        if (clickedEnemy) {
            selectedEnemy = clickedEnemy;
            showStats(selectedEnemy);
            return; // Don't process other clicks when selecting enemy
        } else {
            // Clear enemy selection when clicking elsewhere
            selectedEnemy = null;
            hideStats();
        }
        
        // If clicking on a tower, select it and show stats
        let tower = towers.find(t => t.x === tx && t.y === ty);
        if (tower) {
            selectedTower = tower;
            showTowerStats(tower, mx + app.view.getBoundingClientRect().left, my + app.view.getBoundingClientRect().top);
            selectedTowerType = -1; // Deselect tower type when selecting a placed tower
            renderTowerSelect();
            updateUI();
            return;
        } else {
            selectedTower = null;
        }
        
        // Check for item collection
        for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (Math.hypot(item.x - mx, item.y - my) < 20) {
                collectItem(item);
                items.splice(i, 1);
                return;
            }
        }
        
        // Only place tower if a tower type is selected AND this is not a touch event
        // Touch events will handle placement differently
        if (selectedTowerType >= 0 && e.type !== 'touchstart') {
            placeTowerAtPosition(tx, ty);
        }
    }
    
    // Helper function to handle touch start events (mobile only)
    function handleTouchStart(e) {
        e.preventDefault();
        
        const {mx, my} = getEventCoordinates(e);
        const tx = Math.floor(mx / TILE_SIZE);
        const ty = Math.floor(my / TILE_SIZE);
        
        // If a tower type is selected, start mobile placement mode
        if (selectedTowerType >= 0) {
            isTouchPlacement = true;
            // Set initial mobile preview position
            if (tx >= 0 && tx < GRID_SIZE && ty >= 0 && ty < GRID_SIZE &&
                !(tx === startTile.x && ty === startTile.y) &&
                !(tx === endTile.x && ty === endTile.y) &&
                !towers.some(t => t.x === tx && t.y === ty)) {
                mobilePreviewTile = {x: tx, y: ty};
            }
            return;
        }
        
        // Otherwise, handle as regular click event
        handleClickEvent(e);
    }
    
    // Helper function to handle touch end events (mobile only)
    function handleTouchEnd(e) {
        e.preventDefault();
        
        if (isTouchPlacement && selectedTowerType >= 0 && mobilePreviewTile) {
            // Place the tower at the preview position
            placeTowerAtPosition(mobilePreviewTile.x, mobilePreviewTile.y);
        }
        
        // Reset mobile placement state
        isTouchPlacement = false;
        mobilePreviewTile = null;
        previewTile = null;
    }
    
    // Helper function to place tower at given position
    function placeTowerAtPosition(tx, ty) {
        if (tx < 0 || tx >= GRID_SIZE || ty < 0 || ty >= GRID_SIZE) return;
        if (towers.some(t => t.x === tx && t.y === ty)) return;
        if (tx === startTile.x && ty === startTile.y) return;
        if (tx === endTile.x && ty === endTile.y) return;
        if (gold < TOWER_TYPES[selectedTowerType].cost) return;
        
        towers.push({
            x: tx, y: ty, type: TOWER_TYPES[selectedTowerType], level: 1, cooldown: 0
        });
        gold -= TOWER_TYPES[selectedTowerType].cost;
        updatePathGrid();
        
        // Recalculate path for all non-flying, alive enemies
        enemies.forEach(e => {
            if (!e.flying && e.alive) {
                e.path = aStar({x: Math.round((e.x-TILE_SIZE/2)/TILE_SIZE), y: Math.round((e.y-TILE_SIZE/2)/TILE_SIZE)}, endTile);
                e.pathIdx = 0;
            }
        });
        
        let path = aStar(startTile, endTile);
        if (!path) {
            let t = towers.pop();
            gold += TOWER_TYPES[selectedTowerType].cost;
            updatePathGrid();
            let blocking = towers.filter(tw => {
                towers = towers.filter(tt => tt !== tw);
                updatePathGrid();
                let p = aStar(startTile, endTile);
                towers.push(tw);
                updatePathGrid();
                return !p;
            });
            if (blocking.length) {
                let destroyed = blocking[Math.floor(Math.random()*blocking.length)];
                towers = towers.filter(tw => tw !== destroyed);
                updatePathGrid();
                let g = new PIXI.Graphics();
                g.beginFill(0xde6e6e).drawRect(destroyed.x*TILE_SIZE, destroyed.y*TILE_SIZE, TILE_SIZE, TILE_SIZE).endFill();
                app.stage.addChild(g);
                setTimeout(()=>app.stage.removeChild(g), 500);
            }
        }
        
        selectedTowerType = -1;
        renderTowerSelect();
        updateUI();
    }
      // Mouse events
    app.view.addEventListener('mousemove', handleMoveEvent);
    app.view.addEventListener('mouseleave', () => {
        previewTile = null;
        mobilePreviewTile = null;
    });
    app.view.addEventListener('click', handleClickEvent);
    
    // Touch events - separate handlers for better mobile control
    app.view.addEventListener('touchmove', (e) => {
        if (isTouchPlacement) {
            // During touch placement, update the preview position
            handleMoveEvent(e);
        } else {
            // Regular touch move handling
            handleMoveEvent(e);
        }
    });
    app.view.addEventListener('touchstart', handleTouchStart);
    app.view.addEventListener('touchend', handleTouchEnd);
}

// --- Bomb Functions ---
function placeBomb(x, y) {
    if (bombCount <= 0) return;
    
    // Create explosion effect
    const explosion = {
        x: x,
        y: y,
        radius: 0,
        maxRadius: BOMB_CONFIG.radius,
        alpha: 1,
        duration: BOMB_CONFIG.explosionDuration * 60, // Convert to frames
        color: BOMB_CONFIG.color
    };
    explosions.push(explosion);
    
    // Apply damage to all enemies in radius
    let enemiesHit = 0;
    let totalDamage = 0;
    
    enemies.filter(e => e.alive).forEach(enemy => {
        const distance = Math.hypot(enemy.x - x, enemy.y - y);
        if (distance <= BOMB_CONFIG.radius) {
            // Calculate damage with distance falloff
            const damageRatio = 1 - (distance / BOMB_CONFIG.radius);
            const damage = Math.round(BOMB_CONFIG.damage * damageRatio * 10) / 10;
            totalDamage += damage;
            
            enemy.hp -= damage;
            createDamageNumber(enemy.x, enemy.y - 20, damage);
            enemiesHit++;
            
            if (enemy.hp <= 0) {
                enemy.alive = false;
                gold += enemy.type.reward;
                tryDropItem(enemy.x, enemy.y);
            }
        }
    });
    
    // Decrement bomb count
    bombCount--;
    updateUI();
    
    // Exit bomb placement mode
    placingBomb = false;
    
    if (enemiesHit > 0) {
        showMessage(`Bomb hit ${enemiesHit} enemies for ${Math.round(totalDamage)} damage!`, "#ff5500");
    } else {
        showMessage(`Bomb exploded but hit no enemies.`, "#ff5500");
    }
}

// --- Enemy Spawning ---
function spawnWave() {
    spawningWave = true;
    let count = 8 + wave * 2;
    
    // Get the wave pattern for this wave
    const wavePattern = getWavePattern(wave);
    
    // Apply wave scaling to enemies
    let availableEnemyTypes = [];
    
    // Get enemy types based on wave pattern
    if (wavePattern.name === "Boss Wave") {
        // Scale boss stats for boss waves
        const hpScale = 1 + (wave - 1) * BOSS_TYPE.waveScaling.hp;
        const speedScale = 1 + (wave - 1) * BOSS_TYPE.waveScaling.speed;
        
        availableEnemyTypes.push({
            ...BOSS_TYPE,
            hp: Math.round(BOSS_TYPE.baseHp * hpScale),
            speed: BOSS_TYPE.baseSpeed * speedScale
        });
        count = 1; // Only one boss
    } else if (wavePattern.name === "Air Wave") {
        // Air Wave: Half the enemies at 1/3rd speed
        count = Math.max(1, Math.floor(count / 2)); // Half the enemies, minimum 1
        
        // Regular wave - filter enemy types based on pattern
        const patternEnemyNames = wavePattern.enemies;
        
        ENEMY_TYPES.forEach(enemy => {
            if (patternEnemyNames.includes(enemy.name)) {
                // Calculate HP and speed scaling based on wave number
                const hpScale = 1 + (wave - 1) * enemy.waveScaling.hp;
                const speedScale = 1 + (wave - 1) * enemy.waveScaling.speed;
                
                availableEnemyTypes.push({
                    ...enemy,
                    hp: Math.round(enemy.baseHp * hpScale),
                    speed: (enemy.baseSpeed * speedScale) *.75, // Air enemies move slower
                });
            }
        });
    } else {
        // Regular wave - filter enemy types based on pattern
        const patternEnemyNames = wavePattern.enemies;
        
        ENEMY_TYPES.forEach(enemy => {
            if (patternEnemyNames.includes(enemy.name)) {
                // Calculate HP and speed scaling based on wave number
                const hpScale = 1 + (wave - 1) * enemy.waveScaling.hp;
                const speedScale = 1 + (wave - 1) * enemy.waveScaling.speed;
                
                availableEnemyTypes.push({
                    ...enemy,
                    hp: Math.round(enemy.baseHp * hpScale),
                    speed: enemy.baseSpeed * speedScale
                });
            }
        });
    }
    
    // Calculate spawn interval using spawnDuration from wave patterns configuration
    const spawnInterval = WAVE_PATTERNS.spawnDuration / count; // milliseconds between each spawn
    
    // Create spawn queue with timing
    enemySpawnQueue = [];
    for (let i = 0; i < count; i++) {
        let type = availableEnemyTypes[Math.floor(Math.random() * availableEnemyTypes.length)];
        
        enemySpawnQueue.push({
            type,
            spawnTime: Date.now() + (i * spawnInterval),
            xOffset: i * 10 // Offset to prevent enemies stacking
        });
    }
    
    showMessage(`Wave ${wave}: ${wavePattern.name}!`, "#6e8fde");
}

// --- Game Loop ---
let swordSwings = []; // Track active sword swing animations

function gameLoop(delta) {
    // These updates should run regardless of game state
    
    // Update boost cooldown
    if (!boostActive && boostCooldown > 0) {
        boostCooldown -= delta / 60;
        if (boostCooldown <= 0) {
            boostCooldown = 0;
        }
        updateUI(); // Always update UI when boost timer changes
    }
    
    // Process enemy spawn queue
    if (spawningWave && enemySpawnQueue.length > 0) {
        const currentTime = Date.now();
        
        // Check if it's time to spawn the next enemy
        while (enemySpawnQueue.length > 0 && enemySpawnQueue[0].spawnTime <= currentTime) {
            const enemyData = enemySpawnQueue.shift();
            
            enemies.push({
                type: enemyData.type,
                x: startTile.x * TILE_SIZE + TILE_SIZE/2 - enemyData.xOffset,
                y: startTile.y * TILE_SIZE + TILE_SIZE/2,
                hp: enemyData.type.hp,
                maxHp: enemyData.type.hp,
                speed: enemyData.type.speed,
                path: enemyData.type.flying ? null : aStar(startTile, endTile),
                pathIdx: 0,
                flying: !!enemyData.type.flying,
                alive: true
            });
        }
        
        // End spawning wave when queue is empty
        if (enemySpawnQueue.length === 0) {
            spawningWave = false;
        }
    }
    
    // Update active effects
    for (let i = activeEffects.length - 1; i >= 0; i--) {
        const effect = activeEffects[i];
        effect.duration -= delta;
        if (effect.duration <= 0) {
            activeEffects.splice(i, 1);
        }
    }
    
    // Update items
    for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        item.lifetime -= delta;
        
        // Animate items
        item.pulseValue += 0.05 * item.pulseDirection;
        if (item.pulseValue > 1) {
            item.pulseValue = 1;
            item.pulseDirection = -1;
        } else if (item.pulseValue < 0) {
            item.pulseValue = 0;
            item.pulseDirection = 1;
        }
        
        if (item.lifetime <= 0) {
            items.splice(i, 1);
        }
    }
    
    // Update explosions
    for (let i = explosions.length - 1; i >= 0; i--) {
        const explosion = explosions[i];
        explosion.duration--;
        
        // Grow the explosion
        if (explosion.radius < explosion.maxRadius) {
            explosion.radius += explosion.maxRadius / 15; // Make it expand a bit faster
        }
        
        // Fade out toward the end
        if (explosion.duration < 30) {
            explosion.alpha = explosion.duration / 30;
        }
        
        if (explosion.duration <= 0) {
            explosions.splice(i, 1);
        }
    }
    
    // Update splash effects
    for (let i = splashEffects.length - 1; i >= 0; i--) {
        const splash = splashEffects[i];
        splash.duration--;
        
        // Grow the splash effect
        if (splash.radius < splash.maxRadius) {
            splash.radius += splash.maxRadius / 10;
        }
        
        // Fade out toward the end
        if (splash.duration < 20) {
            splash.alpha = splash.duration / 20;
        }
        
        if (splash.duration <= 0) {
            splashEffects.splice(i, 1);
        }
    }
    
    // Update sword swing animations
    for (let i = swordSwings.length - 1; i >= 0; i--) {
        const swing = swordSwings[i];
        swing.duration--;
        
        if (swing.duration <= 0) {
            swordSwings.splice(i, 1);
        }
    }
    
    // --- Update damage numbers (regardless of game state) ---
    for (let i = damageNumbers.length - 1; i >= 0; i--) {
        let d = damageNumbers[i];
        d.life--;
        
        // Apply physics to damage numbers for bouncing effect
        d.y += d.yVel;
        d.x += d.xVel;
        d.yVel += 0.15; // Gravity
        d.alpha = d.life / 45;
        
        // Release the text object back to pool if number is dead
        if (d.life <= 0) {
            if (d.textObj) {
                d.textObj.visible = false;
                d.textObj = null;
            }
            damageNumbers.splice(i, 1);
        }
    }
    
    // Skip game logic if not running
    if (!isGameRunning) {
        // Still draw to ensure damage numbers and other visual elements update
        draw();
        return;
    }
    
    // --- Move Enemies ---
    for (let enemy of enemies) {
        if (!enemy.alive) continue;
        
        // Update slowed status if present
        if (enemy.slowed) {
            enemy.slowed.duration -= delta;
            
            // Remove slow effect when duration expires
            if (enemy.slowed.duration <= 0) {
                enemy.speed = enemy.slowed.originalSpeed; // Restore original speed
                enemy.slowed = null;
            }
        }
        
        if (enemy.flying) {
            // Flying: straight line
            let dx = (endTile.x*TILE_SIZE+TILE_SIZE/2) - enemy.x;
            let dy = (endTile.y*TILE_SIZE+TILE_SIZE/2) - enemy.y;
            let dist = Math.sqrt(dx*dx+dy*dy);
            
            if (dist < 6) {
                enemy.alive = false;
                // Boss enemies cause 3 life loss, others cause 1
                const livesLost = enemy.type.name === "Boss" ? 3 : 1;
                lives -= livesLost;
                if (livesLost === 3) {
                    showMessage("Boss Escaped! 3 Lives Lost!", "#ff6666");
                } else {
                    showMessage("Life Lost!", "#ff6666");
                }
                continue;
            }
            
            let spd = enemy.speed * delta * 2.2;
            enemy.x += dx/dist * spd;
            enemy.y += dy/dist * spd;
        } else {
            if (!enemy.path || enemy.pathIdx >= enemy.path.length) {
                enemy.alive = false;
                // Boss enemies cause 3 life loss, others cause 1
                const livesLost = enemy.type.name === "Boss" ? 3 : 1;
                lives -= livesLost;
                if (livesLost === 3) {
                    showMessage("Boss Escaped! 3 Lives Lost!", "#ff6666");
                } else {
                    showMessage("Life Lost!", "#ff6666");
                }
                continue;
            }
            
            let node = enemy.path[enemy.pathIdx];
            let tx = node.x*TILE_SIZE+TILE_SIZE/2;
            let ty = node.y*TILE_SIZE+TILE_SIZE/2;
            let dx = tx - enemy.x;
            let dy = ty - enemy.y;
            let dist = Math.sqrt(dx*dx+dy*dy);
            let spd = enemy.speed * delta * 2.2;
            
            if (dist < spd) {
                enemy.x = tx;
                enemy.y = ty;
                enemy.pathIdx++;
            } else {
                enemy.x += dx/dist * spd;
                enemy.y += dy/dist * spd;
            }
        }
    }
    
    // --- Towers Attack ---
    for (let tower of towers) {
        // Apply boost if active
        let fireRateMultiplier = 1;
        if (boostActive) {
            fireRateMultiplier *= BOOST_CONFIG.speedMultiplier;
        }
        
        // Apply active effects
        const fireRateEffect = activeEffects.find(e => e.type === "fireRate");
        if (fireRateEffect) {
            fireRateMultiplier *= (1 + fireRateEffect.multiplier);
        }
        
        tower.cooldown -= (delta/60) * fireRateMultiplier;
        
        if (tower.cooldown <= 0) {
            if (tower.type.name === "Melee") {
                // Melee towers can't target flying enemies and hit all enemies at once
                let targets = enemies.filter(e => 
                    e.alive && 
                    !e.flying &&
                    Math.hypot(e.x-(tower.x*TILE_SIZE+TILE_SIZE/2), e.y-(tower.y*TILE_SIZE+TILE_SIZE/2)) < tower.type.range
                );
                
                if (targets.length) {
                    // Create a sword swing animation
                    swordSwings.push({
                        x: tower.x*TILE_SIZE+TILE_SIZE/2,
                        y: tower.y*TILE_SIZE+TILE_SIZE/2,
                        radius: tower.type.range,
                        duration: 15, // Animation lasts 15 frames
                        angle: Math.random() * Math.PI * 2, // Random starting angle
                        color: tower.type.color,
                        element: tower.type.element
                    });
                    
                    // Hit all targets in range
                    for (let target of targets) {
                        // Calculate damage with randomness, critical hits, and elemental effects
                        const { damage, isCritical, elementalEffect, elementalMultiplier } = calculateDamage(tower, target);
                        
                        // Apply damage boost if active
                        let finalDamage = damage;
                        const damageEffect = activeEffects.find(e => e.type === "damage");
                        if (damageEffect) {
                            finalDamage *= (1 + damageEffect.multiplier);
                        }
                        
                        target.hp -= finalDamage;
                        
                        // Create damage number with elemental effect info
                        createDamageNumber(target.x, target.y - 20, finalDamage, isCritical, elementalEffect, elementalMultiplier);
                        
                        if (target.hp <= 0) {
                            target.alive = false;
                            gold += target.type.reward;
                            tryDropItem(target.x, target.y);
                        }
                    }
                    
                    tower.cooldown = tower.type.fireRate;
                }
            } else if (tower.type.name === "Anti-Air") {
                // Anti-Air towers only target flying enemies
                let targets = enemies.filter(e => 
                    e.alive && 
                    e.flying &&
                    Math.hypot(e.x-(tower.x*TILE_SIZE+TILE_SIZE/2), e.y-(tower.y*TILE_SIZE+TILE_SIZE/2)) < tower.type.range
                );
                
                if (targets.length) {
                    let target = targets[0];
                    
                    // Calculate damage with randomness, critical hits, and elemental effects
                    const { damage, isCritical, elementalEffect, elementalMultiplier } = calculateDamage(tower, target);
                    
                    // Apply damage boost if active
                    let finalDamage = damage;
                    const damageEffect = activeEffects.find(e => e.type === "damage");
                    if (damageEffect) {
                        finalDamage *= (1 + damageEffect.multiplier);
                    }
                    
                    projectiles.push({
                        x: tower.x*TILE_SIZE+TILE_SIZE/2,
                        y: tower.y*TILE_SIZE+TILE_SIZE/2,
                        tx: target.x,
                        ty: target.y,
                        target,
                        damage: finalDamage,
                        color: tower.type.color,
                        isCritical,
                        elementalEffect,
                        elementalMultiplier,
                        element: tower.type.element,
                        towerType: tower.type.name,
                        originTower: tower,
                        speed: 9 + tower.level*2 // Faster projectiles for anti-air
                    });
                    
                    tower.cooldown = tower.type.fireRate;
                }
            } else {
                // Regular tower behavior
                let targets = enemies.filter(e => 
                    e.alive && 
                    Math.hypot(e.x-(tower.x*TILE_SIZE+TILE_SIZE/2), e.y-(tower.y*TILE_SIZE+TILE_SIZE/2)) < tower.type.range
                );
                
                if (targets.length) {
                    let target = targets[0];
                    
                    // Calculate damage with randomness, critical hits, and elemental effects
                    const { damage, isCritical, elementalEffect, elementalMultiplier } = calculateDamage(tower, target);
                    
                    // Apply damage boost if active
                    let finalDamage = damage;
                    const damageEffect = activeEffects.find(e => e.type === "damage");
                    if (damageEffect) {
                        finalDamage *= (1 + damageEffect.multiplier);
                    }
                    
                    projectiles.push({
                        x: tower.x*TILE_SIZE+TILE_SIZE/2,
                        y: tower.y*TILE_SIZE+TILE_SIZE/2,
                        tx: target.x,
                        ty: target.y,
                        target,
                        damage: finalDamage,
                        color: tower.type.color,
                        isCritical,
                        elementalEffect,
                        elementalMultiplier,
                        element: tower.type.element,
                        towerType: tower.type.name, // Add tower type to projectile
                        originTower: tower, // Reference to tower for effect application
                        speed: 7 + tower.level*2
                    });
                    
                    tower.cooldown = tower.type.fireRate;
                }
            }
        }
    }
    
    // --- Projectiles ---
    for (let p of projectiles) {
        let dx = p.tx - p.x;
        let dy = p.ty - p.y;
        let dist = Math.sqrt(dx*dx+dy*dy);
        let spd = p.speed;
        
        // Store the direction for trail rendering
        p.dirX = dx / dist;
        p.dirY = dy / dist;
        
        if (dist < spd) {
            p.x = p.tx;
            p.y = p.ty;
            
            if (p.target && p.target.alive) {
                p.target.hp -= p.damage;
                
                // Create damage number with elemental effect info
                createDamageNumber(p.target.x, p.target.y - 20, p.damage, p.isCritical, p.elementalEffect, p.elementalMultiplier);
                
                // Apply slow effect if from a Slow Tower
                if ( p.towerType === "Slow") {
                    applySlowEffect(p.target, p.originTower);
                }
                
                // Check for splash damage (Missile(Splash) tower)
                if (p.towerType === "Missile(Splash)" && p.originTower.type.splashRadius > 0) {
                    // Create splash effect animation
                    splashEffects.push({
                        x: p.target.x,
                        y: p.target.y,
                        radius: 0,
                        maxRadius: p.originTower.type.splashRadius,
                        alpha: 0.8,
                        duration: 30,
                        color: p.originTower.type.color
                    });
                    
                    // Apply splash damage to nearby enemies
                    enemies.filter(e => e.alive && e !== p.target).forEach(enemy => {
                        const distance = Math.hypot(enemy.x - p.target.x, enemy.y - p.target.y);
                        if (distance <= p.originTower.type.splashRadius) {
                            const splashDamage = p.damage * p.originTower.type.splashDamageRatio;
                            enemy.hp -= splashDamage;
                            
                            // Create splash damage number
                            createSplashDamageNumber(enemy.x, enemy.y - 20, splashDamage);
                            
                            if (enemy.hp <= 0) {
                                enemy.alive = false;
                                gold += enemy.type.reward;
                                tryDropItem(enemy.x, enemy.y);
                            }
                        }
                    });
                }
                
                if (p.target.hp <= 0) {
                    p.target.alive = false;
                    gold += p.target.type.reward;
                    tryDropItem(p.target.x, p.target.y);
                }
            }
            
            p.hit = true;
        } else {
            p.x += dx/dist * spd;
            p.y += dy/dist * spd;
        }
    }
    
    projectiles = projectiles.filter(p => !p.hit);
    
    // --- Remove Dead Enemies ---
    // First remove emoji text objects for dead enemies
    enemies.filter(e => !e.alive).forEach(e => {
        // Clean up emoji text objects when enemies die
        if (e.emojiText) {
            app.stage.removeChild(e.emojiText);
            e.emojiText = null;
        }
        
        // Clear selected enemy if it dies
        if (selectedEnemy === e) {
            selectedEnemy = null;
            hideStats();
        }
    });
    // Then filter out dead enemies
    enemies = enemies.filter(e => e.alive);
      // --- Win/Lose ---
    if (lives <= 0) {
        isGameRunning = false;
        endBtn.style.display = '';
        startBtn.style.display = 'none';
        nextWaveBtn.style.display = 'none';
        
        // Update mobile buttons
        if (endBtnMobile) endBtnMobile.style.display = '';
        if (startBtnMobile) startBtnMobile.style.display = 'none';
        if (nextWaveBtnMobile) nextWaveBtnMobile.style.display = 'none';
        
        showGameOver('Game Over!');
    } else if (!spawningWave && enemies.length === 0 && projectiles.length === 0 && isGameRunning) {
        isGameRunning = false;
        nextWaveBtn.style.display = '';
        
        // Update mobile buttons
        if (nextWaveBtnMobile) nextWaveBtnMobile.style.display = '';
        
        // Award completion gold
        gold += CONFIG.gameSettings.waveCompleteGold;
        showMessage(`Wave ${wave} complete! +${CONFIG.gameSettings.waveCompleteGold} gold`, "#6ede8a");
    }
    
    updateUI();
    draw();
}

// --- Calculate damage with randomness, crits and elemental effects ---
function calculateDamage(tower, enemy) {
    const baseDamage = tower.type.damage * tower.level;
    const variation = tower.type.damageVariation;
    
    // Random damage variation
    const randomFactor = 1 + (Math.random() * variation * 2 - variation);
    let damage = baseDamage * randomFactor;
    
    // Critical hit check
    const isCritical = Math.random() < tower.type.critChance;
    if (isCritical) {
        damage *= tower.type.critMultiplier;
    }
    
    // Apply elemental effects
    let elementalMultiplier = 1;
    let elementalEffect = null;
    
    // Tower element
    const attackElement = tower.type.element;
    // Enemy element and properties
    const enemyElement = enemy.type.element;
    const elementalProps = enemy.type.elementalProperties || { weaknesses: {}, resistances: {} };
    
    // Check for weaknesses
    if (elementalProps.weaknesses && elementalProps.weaknesses[attackElement]) {
        elementalMultiplier = 1 + (1 - elementalProps.weaknesses[attackElement]);
        elementalEffect = "weakness";
    }
    // Check for resistances
    else if (elementalProps.resistances && elementalProps.resistances[attackElement]) {
        elementalMultiplier = elementalProps.resistances[attackElement];
        elementalEffect = "resistance";
    }
    
    // Apply the multiplier
    damage *= elementalMultiplier;
    
    return { 
        damage: Math.round(damage * 10) / 10, // Round to 1 decimal
        isCritical,
        elementalEffect,
        elementalMultiplier
    };
}

// --- Tower Stats Window ---
function showTowerStats(tower, x, y) {
    // Create stats window
    let statsWindow = document.createElement('div');
    statsWindow.style.position = 'absolute';
    statsWindow.style.background = '#23273a';
    statsWindow.style.color = '#fff';
    statsWindow.style.padding = '15px 20px';
    statsWindow.style.borderRadius = '8px';
    statsWindow.style.boxShadow = '0 2px 24px #000a';
    statsWindow.style.zIndex = '1000';
    statsWindow.style.minWidth = '200px';
    statsWindow.style.pointerEvents = 'auto';
    statsWindow.style.maxWidth = '280px';
    
    // Add close button (X) in the top right
    let closeBtn = document.createElement('div');
    closeBtn.innerHTML = 'Ã—';
    closeBtn.style.position = 'absolute';
    closeBtn.style.top = '5px';
    closeBtn.style.right = '10px';
    closeBtn.style.fontSize = '24px';
    closeBtn.style.cursor = 'pointer';
    closeBtn.style.color = '#fff';
    closeBtn.style.lineHeight = '20px';
    closeBtn.onclick = () => {
        document.body.removeChild(statsWindow);
        towerStatsWindow = null;
    };
    
    // Create content elements
    let title = document.createElement('h3');
    title.style.margin = '0 0 10px 0';
    title.textContent = `${tower.type.name} Tower (Level ${tower.level})`;
    
    // Stats container
    let statsContainer = document.createElement('div');
    statsContainer.style.marginBottom = '15px';
    
    // Add stats including damage variation and critical hit info
    const baseDamage = tower.type.damage * tower.level;
    const variation = tower.type.damageVariation;
    const minDamage = Math.floor(baseDamage * (1 - variation));
    const maxDamage = Math.ceil(baseDamage * (1 + variation));
    const critChance = tower.type.critChance * 100;
    const critMultiplier = tower.type.critMultiplier;
    const damagePerSec = baseDamage / tower.type.fireRate;
    
    // Get element info
    const elementInfo = ELEMENTS[tower.type.element] || { name: "Physical", color: "0xcccccc" };
    const elementName = elementInfo.name;
    const elementColor = '#' + elementInfo.color.toString(16).padStart(6, '0');
    const elementEmoji = elementInfo.emoji || "";
    
    
    let stats = [
        `Damage: ${minDamage}-${maxDamage}`,
        `Critical Hit: ${critChance.toFixed(1)}% chance (Ã—${critMultiplier})`,
        `Range: ${tower.type.range}`,
        `Fire Rate: ${(1 / tower.type.fireRate).toFixed(1)}/sec`,
        `DPS: ${damagePerSec.toFixed(1)}`,
    ];
    
    // Add slow effect info for Slow Tower
    if (tower.type.name === "Slow") {
        stats.push(`Slow: ${SLOW_CONFIG.slowAmount * 100}% for ${SLOW_CONFIG.slowDuration}s`);
    }
    
    // Add special targeting info for Anti-Air
    if (tower.type.name === "Anti-Air") {
        stats.push(`Special: Only targets flying enemies`);
    }
    
    // Add splash damage info for Missile(Splash) Tower
    if (tower.type.name === "Missile(Splash)") {
        stats.push(`Splash: ${(tower.type.splashDamageRatio * 100).toFixed(0)}% damage in ${tower.type.splashRadius}px radius`);
    }
    
    stats.unshift(`Element: <span class="element-icon" style="background: ${elementColor}">${elementEmoji}</span> ${elementName}`);
    
    stats.forEach(stat => {
        let div = document.createElement('div');
        div.innerHTML = stat;
        statsContainer.appendChild(div);
    });
    
    // Buttons container
    let buttonsContainer = document.createElement('div');
    buttonsContainer.style.display = 'flex';
    buttonsContainer.style.justifyContent = 'space-between';
    buttonsContainer.style.gap = '10px';
    
    // Upgrade button
    let upgradeBtn = document.createElement('button');
    upgradeBtn.textContent = `Upgrade (${Math.floor(tower.type.cost*0.7*tower.level)})`;
    upgradeBtn.onclick = () => {
        let cost = Math.floor(tower.type.cost*0.7*tower.level);
        if (gold >= cost) {
            gold -= cost;
            tower.level++;
            updateUI();
            // Update the stats window with new values

            document.body.removeChild(statsWindow);
            showTowerStats(tower, x, y);
        }
    };
    
    // Sell button
    let sellBtn = document.createElement('button');
    sellBtn.textContent = `Sell (${Math.floor(tower.type.cost*0.5*tower.level)})`;
    sellBtn.onclick = () => {
        gold += Math.floor(tower.type.cost*0.5*tower.level);
        towers = towers.filter(t => t !== tower);
        updatePathGrid();
        document.body.removeChild(statsWindow);
        towerStatsWindow = null;
        selectedTower = null;
        updateUI();
    };
    
    // Assemble the window    statsWindow.appendChild(closeBtn);
    statsWindow.appendChild(title);
    statsWindow.appendChild(statsContainer);
    buttonsContainer.appendChild(upgradeBtn);
    buttonsContainer.appendChild(sellBtn);
    statsWindow.appendChild(buttonsContainer);
    
    // Add to DOM first (positioned off-screen temporarily)
    statsWindow.style.left = '-9999px';
    statsWindow.style.top = '-9999px';
    document.body.appendChild(statsWindow);
    towerStatsWindow = statsWindow;
    
    // Now measure the window dimensions and position it properly
    const windowRect = statsWindow.getBoundingClientRect();
    const viewportWidth = window.innerWidth;
    const viewportHeight = window.innerHeight;
    
    // Calculate preferred position (offset from click)
    let preferredLeft = x + 20;
    let preferredTop = y - 20;
    
    // Adjust horizontal position if it would go off-screen
    if (preferredLeft + windowRect.width > viewportWidth) {
        // Position to the left of the click point instead
        preferredLeft = x - windowRect.width - 20;
        
        // If it still goes off-screen to the left, clamp it
        if (preferredLeft < 10) {
            preferredLeft = 10;
        }
    }
    
    // Adjust vertical position if it would go off-screen
    if (preferredTop + windowRect.height > viewportHeight) {
        // Position above the click point instead
        preferredTop = y - windowRect.height - 20;
        
        // If it still goes off-screen at the top, clamp it
        if (preferredTop < 10) {
            preferredTop = 10;
        }
    }
    
    // Ensure minimum margins from edges
    preferredLeft = Math.max(10, Math.min(preferredLeft, viewportWidth - windowRect.width - 10));
    preferredTop = Math.max(10, Math.min(preferredTop, viewportHeight - windowRect.height - 10));
    
    // Apply the final position
    statsWindow.style.left = preferredLeft + 'px';
    statsWindow.style.top = preferredTop + 'px';
    
    // Close the window when clicking outside
    document.addEventListener('mousedown', function closeStatsWindow(e) {
        if (!statsWindow.contains(e.target) && e.target !== statsWindow) {
            document.body.removeChild(statsWindow);
            towerStatsWindow = null;
            document.removeEventListener('mousedown', closeStatsWindow);
        }
    });
}

// --- Handle item collection ---
function collectItem(item) {
    if (item.type.name === "Gold") {
        gold += item.type.value;
        showMessage(`+${item.type.value} Gold!`, "#ffd700");
    }
    else if (item.type.name === "Damage Boost") {
        activeEffects.push({
            type: "damage",
            multiplier: item.type.value,
            duration: item.type.duration * 60 // Convert to frames
        });
        showMessage(`Damage Boost +${Math.round(item.type.value * 100)}% for ${item.type.duration}s!`, "#ff4500");
    }
    else if (item.type.name === "Speed Boost") {
        activeEffects.push({
            type: "fireRate",
            multiplier: item.type.value,
            duration: item.type.duration * 60 // Convert to frames
        });
        showMessage(`Fire Rate Boost +${Math.round(item.type.value * 100)}% for ${item.type.duration}s!`, "#00ffff");
    }
}

// --- Try to drop an item from defeated enemy ---
function tryDropItem(x, y) {
    if (Math.random() < CONFIG.gameSettings.itemDropChance) {
        // Weighted random selection of item type
        const totalWeight = ITEM_TYPES.reduce((sum, item) => sum + item.weight, 0);
        let roll = Math.random() * totalWeight;
        let selectedItem = null;
        
        for (const item of ITEM_TYPES) {
            roll -= item.weight;
            if (roll <= 0) {
                selectedItem = item;
                break;
            }
        }
        
        if (selectedItem) {
            items.push({
                x, y,
                type: selectedItem,
                pulseDirection: 1,
                pulseValue: 0,
                lifetime: 300 // Item disappears after 5 seconds (60 frames/sec)
            });
        }
    }
}

// --- Damage Numbers ---
function createDamageNumber(x, y, damage, isCritical = false, elementalEffect = null, elementalMultiplier = 1) {
    // Add random horizontal offset and velocity for bounce effect
    const randX = (Math.random() - 0.5) * 30;
    const randYVel = -2 - Math.random() * 2; // Initial upward velocity
    
    // Determine color based on critical and elemental effects
    let color = 0xFFFFFF; // Default white
    
    if (isCritical) {
        color = 0xff5500; // Critical hits are orange
    } 
    else if (elementalEffect === "weakness") {
        color = 0x66dd66; // Weakness hits are green (more damage)
    }
    else if (elementalEffect === "resistance") {
        color = 0xdd6666; // Resistance hits are red (less damage)
    }
    
    // Prepare text for display
    let displayText = Math.floor(damage).toString();
    
    // Add a prefix for elemental effects
    if (elementalEffect === "weakness") {
        displayText = "+" + displayText; 
    } else if (elementalEffect === "resistance") {
        displayText = "-" + displayText;
    }
    
    damageNumbers.push({
        x: x + randX,
        y: y,
        damage: damage,
        displayText: displayText,
        color: color,
        alpha: 1,
        life: 45, // Increased lifetime slightly
        isCritical,
        elementalEffect,
        xVel: (Math.random() - 0.5) * 1.5, // Horizontal velocity
        yVel: randYVel, // Vertical velocity (upward)
        textObj: null // Will be assigned from pool during rendering
    });
}

// --- Splash Damage Numbers ---
function createSplashDamageNumber(x, y, damage) {
    // Add random horizontal offset and velocity for bounce effect
    const randX = (Math.random() - 0.5) * 30;
    const randYVel = -1.5 - Math.random() * 1.5; // Slightly less upward velocity
    
    // Splash damage numbers are orange/yellow
    const color = 0xffaa00;
    
    // Prepare text for display
    let displayText = Math.floor(damage).toString();
    
    damageNumbers.push({
        x: x + randX,
        y: y,
        damage: damage,
        displayText: displayText,
        color: color,
        alpha: 1,
        life: 35, // Shorter lifetime than regular damage numbers
        isCritical: false, // Splash damage is never critical
        elementalEffect: "splash",
        xVel: (Math.random() - 0.5) * 1.2, // Slightly less horizontal velocity
        yVel: randYVel,
        textObj: null // Will be assigned from pool during rendering
    });
}

// --- Wave Information Functions ---
let cachedWavePatterns = {}; // Cache wave patterns so they don't change

function getWavePattern(waveNumber) {
    // Check if we already have this wave cached
    if (cachedWavePatterns[waveNumber]) {
        return cachedWavePatterns[waveNumber];
    }
    
    let pattern;
    
    // Every 5th wave (5, 15, 25, etc.) is a boss wave
    if (waveNumber % 10 === 5) {
        pattern = WAVE_PATTERNS.patterns.find(p => p.name === "Boss Wave");
    }
    // Every 10th wave (10, 20, 30, etc.) is an air wave
    else if (waveNumber % 10 === 0) {
        pattern = WAVE_PATTERNS.patterns.find(p => p.name === "Air Wave");
    }
    // For all other waves, use a seeded random based on wave number
    else {
        const random = Math.random();
        
        if (random < WAVE_PATTERNS.mixedWaveChance) {
            // 60% chance for mixed wave
            pattern = WAVE_PATTERNS.patterns.find(p => p.name === "Mixed Wave");
        } else {
            // 40% chance for other wave types (Fire, Water, Earth, Normal)
            const otherPatterns = WAVE_PATTERNS.patterns.filter(p => 
                p.name !== "Mixed Wave" && 
                p.name !== "Air Wave" && 
                p.name !== "Boss Wave"
            );
            const randomIndex = Math.floor((random - 0.6) / 0.4 * otherPatterns.length);
            pattern = otherPatterns[randomIndex];
        }
    }
    
    // Cache the pattern so it doesn't change
    cachedWavePatterns[waveNumber] = pattern;
    return pattern;
}

function renderWaveInfo() {
    // Update desktop wave info
    const waveInfoContent = document.getElementById('wave-info-content');
    waveInfoContent.innerHTML = '';
    
    // Show next 5 waves as requested
    for (let i = 0; i < 5; i++) {
        const waveNum = wave + i;
        const pattern = getWavePattern(waveNum);
        
        const waveItem = document.createElement('div');
        waveItem.className = 'wave-info-item';
        if (i === 0) {
            waveItem.classList.add('current');
        }
        
        const waveNumber = document.createElement('div');
        waveNumber.className = 'wave-info-number';
        waveNumber.textContent = waveNum;
        
        const waveIcon = document.createElement('div');
        waveIcon.className = 'wave-info-icon';
        waveIcon.textContent = pattern.icon;
        
        const waveName = document.createElement('div');
        waveName.className = 'wave-info-name';
        waveName.textContent = pattern.name;
        waveName.style.color = '#' + pattern.color.toString(16).padStart(6, '0');
        
        waveItem.appendChild(waveNumber);
        waveItem.appendChild(waveIcon);
        waveItem.appendChild(waveName);
        
        waveInfoContent.appendChild(waveItem);
    }
    
    // Update mobile wave info
    const waveInfoContentMobile = document.getElementById('wave-info-content-mobile');
    if (waveInfoContentMobile) {        waveInfoContentMobile.innerHTML = '';
        
        // Show next 5 waves for mobile (same as desktop)
        for (let i = 0; i < 5; i++) {
            const waveNum = wave + i;
            const pattern = getWavePattern(waveNum);
            
            const waveItem = document.createElement('div');
            waveItem.className = 'wave-info-item';
            if (i === 0) {
                waveItem.classList.add('current');
            }
            
            // Simplified layout for mobile with smaller text
            waveItem.innerHTML = `
                <span style="font-weight: bold; margin-right: 3px; font-size: 0.8em;">${waveNum}</span>
                <span style="margin-right: 2px; font-size: 0.7em;">${pattern.icon}</span>
                <span style="font-size: 0.7em; color: #${pattern.color.toString(16).padStart(6, '0')}">${pattern.name}</span>
            `;
            
            waveInfoContentMobile.appendChild(waveItem);
        }
    }
}

// --- Drawing ---
const graphics = new PIXI.Graphics();
app.stage.addChild(graphics);

function draw() {
    graphics.clear();
    
    // Draw grid
    graphics.lineStyle(1, 0x2e3a4e, 0.5);
    for (let x = 0; x <= GRID_SIZE; x++) {
        graphics.moveTo(x*TILE_SIZE, 0);
        graphics.lineTo(x*TILE_SIZE, MAP_HEIGHT);
    }
    for (let y = 0; y <= GRID_SIZE; y++) {
        graphics.moveTo(0, y*TILE_SIZE);
        graphics.lineTo(MAP_WIDTH, y*TILE_SIZE);
    }
    
    // Draw start/end
    graphics.beginFill(0x6ede8a).drawRect(startTile.x*TILE_SIZE, startTile.y*TILE_SIZE, TILE_SIZE, TILE_SIZE).endFill();
    graphics.beginFill(0xde6e6e).drawRect(endTile.x*TILE_SIZE, endTile.y*TILE_SIZE, TILE_SIZE, TILE_SIZE).endFill();
      // Draw preview tower
    if (previewTile && selectedTowerType >= 0) {
        graphics.beginFill(TOWER_TYPES[selectedTowerType].color, 0.35)
            .drawCircle(previewTile.x*TILE_SIZE+TILE_SIZE/2, previewTile.y*TILE_SIZE+TILE_SIZE/2, TILE_SIZE/2.2)
            .endFill();
    }
    
    // Draw mobile preview tower (with different styling to distinguish from desktop preview)
    if (mobilePreviewTile && selectedTowerType >= 0) {
        // Draw a more prominent preview for mobile with pulsing effect
        const pulseScale = 0.8 + Math.sin(Date.now() / 200) * 0.1; // Pulsing between 0.7 and 0.9
        const radius = (TILE_SIZE/2.2) * pulseScale;
        
        // Draw outer glow ring
        graphics.beginFill(TOWER_TYPES[selectedTowerType].color, 0.2)
            .drawCircle(mobilePreviewTile.x*TILE_SIZE+TILE_SIZE/2, mobilePreviewTile.y*TILE_SIZE+TILE_SIZE/2, radius * 1.3)
            .endFill();
            
        // Draw main preview tower
        graphics.beginFill(TOWER_TYPES[selectedTowerType].color, 0.6)
            .drawCircle(mobilePreviewTile.x*TILE_SIZE+TILE_SIZE/2, mobilePreviewTile.y*TILE_SIZE+TILE_SIZE/2, radius)
            .endFill();
            
        // Draw inner highlight
        graphics.beginFill(0xffffff, 0.4)
            .drawCircle(mobilePreviewTile.x*TILE_SIZE+TILE_SIZE/2, mobilePreviewTile.y*TILE_SIZE+TILE_SIZE/2, radius * 0.5)
            .endFill();
            
        // Draw range indicator for mobile preview
        graphics.lineStyle(2, TOWER_TYPES[selectedTowerType].color, 0.3);
        graphics.drawCircle(mobilePreviewTile.x*TILE_SIZE+TILE_SIZE/2, mobilePreviewTile.y*TILE_SIZE+TILE_SIZE/2, TOWER_TYPES[selectedTowerType].range);
    }
    
    // Draw towers with visual upgrades (constrained to tile size)
    for (let t of towers) {
        // Calculate size based on level (constrained to tile size)
        const maxRadius = TILE_SIZE / 2.2; // Base radius
        const levelBonus = Math.min(t.level - 1, 4) * 0.1; // Cap bonus at 40% (level 5)
        const radius = maxRadius * (1 + levelBonus);
        
        // Draw base tower
        graphics.beginFill(t.type.color)
            .drawCircle(t.x*TILE_SIZE+TILE_SIZE/2, t.y*TILE_SIZE+TILE_SIZE/2, radius)
            .endFill();
        
        // Add visual features based on level
        if (t.level >= 2) {
            // Inner circle for level 2+
            graphics.beginFill(0xffffff, 0.3)
                .drawCircle(t.x*TILE_SIZE+TILE_SIZE/2, t.y*TILE_SIZE+TILE_SIZE/2, radius * 0.6)
                .endFill();
        }
        
        if (t.level >= 3) {
            // Ring for level 3+
            graphics.lineStyle(2, 0xffffff, 0.7)
                .drawCircle(t.x*TILE_SIZE+TILE_SIZE/2, t.y*TILE_SIZE+TILE_SIZE/2, radius * 0.8);
        }
        
        if (t.level >= 4) {
            // Extra detail for level 4+
            graphics.lineStyle(2, 0xffdd00, 0.8)
                .drawCircle(t.x*TILE_SIZE+TILE_SIZE/2, t.y*TILE_SIZE+TILE_SIZE/2, radius * 0.9);
        }
        
        // Show range for selected tower
        if (selectedTower === t) {
            graphics.lineStyle(2, 0xffffff, 0.2);
            graphics.drawCircle(t.x*TILE_SIZE+TILE_SIZE/2, t.y*TILE_SIZE+TILE_SIZE/2, t.type.range);
        }
    }
    
    // Draw sword swings
    for (let swing of swordSwings) {
        // Calculate fade based on duration (starts at 1, fades to 0)
        const fade = swing.duration / 15;
        
        // Calculate swing arc parameters
        const startAngle = swing.angle;
        const endAngle = startAngle + Math.PI * 0.75; // 135 degrees arc
        
        // Draw the sword swing arc
        graphics.lineStyle(4, swing.color, fade)
            .arc(swing.x, swing.y, swing.radius * 0.8, startAngle, endAngle);
            
        // Draw a smaller inner arc for effect
        graphics.lineStyle(2, 0xFFFFFF, fade * 0.8)
            .arc(swing.x, swing.y, swing.radius * 0.6, startAngle, endAngle);
    }
    
    // Draw items
    for (let item of items) {
        const pulseSize = 5 + (item.pulseValue * 3);
        
        // Main item
        graphics.beginFill(parseInt(item.type.color), 0.8)
            .drawCircle(item.x, item.y, pulseSize)
            .endFill();
        
        // Glow effect
        graphics.beginFill(parseInt(item.type.color), 0.3)
            .drawCircle(item.x, item.y, pulseSize * 1.5)
            .endFill();
    }
    
    // Draw enemies
    for (let e of enemies) {
        // Draw enemy
        graphics.beginFill(e.type.color)
            .drawCircle(e.x, e.y, e.type.name === "Boss" ? TILE_SIZE/1.7 : TILE_SIZE/2.5)
            .endFill();
        
        if (e.type.name === "Boss") {
            graphics.lineStyle(3, 0xffffff, 0.7);
            graphics.drawCircle(e.x, e.y, TILE_SIZE/1.7);
        }
        
        // Draw yellow selection circle for selected enemy
        if (selectedEnemy === e) {
            graphics.lineStyle(3, 0xffff00, 0.8); // Yellow circle
            graphics.drawCircle(e.x, e.y, (e.type.name === "Boss" ? TILE_SIZE/1.5 : TILE_SIZE/2.2) + 5);
        }
        
        // Draw slowed effect if enemy is slowed
        if (e.slowed) {
            // Draw frost effect around the enemy
            const pulseAmount = 0.5 + Math.sin(Date.now() / 300) * 0.2; // Pulsing effect
            graphics.lineStyle(3, e.slowed.effectColor, 0.7 * pulseAmount)
                .drawCircle(e.x, e.y, (e.type.name === "Boss" ? TILE_SIZE/1.5 : TILE_SIZE/2.2) + pulseAmount * 3);
            
            // Add some frost particles
            for (let i = 0; i < 2; i++) {
                const angle = Math.random() * Math.PI * 2;
                const distance = (Math.random() * 10) + (e.type.name === "Boss" ? TILE_SIZE/2 : TILE_SIZE/3);
                graphics.beginFill(e.slowed.effectColor, 0.6)
                    .drawCircle(
                        e.x + Math.cos(angle) * distance,
                        e.y + Math.sin(angle) * distance,
                        1 + Math.random() * 2
                    )
                    .endFill();
            }
        }
        
        // Draw element emoji if available
        if (e.type.emoji && e.type.element !== "physical") {
            // Create or reuse text for emoji
            if (!e.emojiText) {
                e.emojiText = new PIXI.Text(e.type.emoji, { 
                    fontSize: e.type.name === "Boss" ? 20 : 14,
                    align: "center"
                });
                e.emojiText.anchor.set(0.5);
                app.stage.addChild(e.emojiText);
            }
            
            // Update position
            e.emojiText.position.x = e.x;
            e.emojiText.position.y = e.y;
            e.emojiText.visible = true;
        } else if (e.emojiText) {
            e.emojiText.visible = false;
        }
        
        // Draw health bar
        const healthPercentage = e.hp / e.maxHp;
        const barWidth = e.type.name === "Boss" ? TILE_SIZE * 1.5 : TILE_SIZE;
        const barHeight = 6;
        const barX = e.x - barWidth / 2;
        const barY = e.y - (e.type.name === "Boss" ? TILE_SIZE/1.3 : TILE_SIZE/1.8);
        
        // Background (dark gray)
        graphics.beginFill(0x333333)
            .drawRect(barX, barY, barWidth, barHeight)
            .endFill();
        
        // Health color based on percentage
        let healthColor;
        if (healthPercentage > 0.6) healthColor = 0x66dd66; // Green
        else if (healthPercentage > 0.3) healthColor = 0xdddd66; // Yellow
        else healthColor = 0xdd6666; // Red
        
        // Health bar (colored)
        graphics.beginFill(healthColor)
            .drawRect(barX, barY, barWidth * healthPercentage, barHeight)
            .endFill();
    }
    
    // Draw projectiles
    for (let p of projectiles) {
        // Basic projectile circle
        graphics.beginFill(p.color).drawCircle(p.x, p.y, 7).endFill();
        
        // Add elemental effect (optional)
        if (p.element && p.element !== "physical") {
            // Inner glow for elemental projectiles
            graphics.beginFill(0xffffff, 0.5).drawCircle(p.x, p.y, 3).endFill();
            
            // Special slow trail for slow tower projectiles
            if (p.towerType === "Slow") {
                const trailLength = 5; // Longer trail for slow
                const trailFade = 0.8; // How quickly the trail fades
                
                // Only draw trail if direction is defined
                if (p.dirX !== undefined && p.dirY !== undefined) {
                    for (let i = 1; i <= trailLength; i++) {
                        const trailOpacity = 0.8 * Math.pow(trailFade, i);
                        const trailX = p.x - (p.dirX * i * 4);
                        const trailY = p.y - (p.dirY * i * 4);
                        
                        // Slow particles along the trail
                        if (i % 2 === 0) {
                            const offsetX = (Math.random() - 0.5) * 5;
                            const offsetY = (Math.random() - 0.5) * 5;
                            graphics.beginFill(SLOW_CONFIG.effectColor, trailOpacity * 0.7)
                                .drawCircle(trailX + offsetX, trailY + offsetY, 2 + Math.random() * 2)
                                .endFill();
                        }
                        
                        // Main trail
                        graphics.beginFill(SLOW_CONFIG.effectColor, trailOpacity)
                            .drawCircle(trailX, trailY, 4 - i * 0.5)
                            .endFill();
                    }
                }
            } else {
                // Regular elemental projectile trail
                const trailLength = 3; // Number of trail segments
                const trailFade = 0.7; // How quickly the trail fades
                
                // Only draw trail if direction is defined
                if (p.dirX !== undefined && p.dirY !== undefined) {
                    for (let i = 1; i <= trailLength; i++) {
                        const trailOpacity = 0.7 * Math.pow(trailFade, i);
                        const trailX = p.x - (p.dirX * i * 4);
                        const trailY = p.y - (p.dirY * i * 4);
                        graphics.beginFill(p.color, trailOpacity)
                            .drawCircle(trailX, trailY, 5 - i)
                            .endFill();
                    }
                }
            }
        }
    }
    
    // Draw damage numbers using text pool
    for (let d of damageNumbers) {
        // Find available text object from pool
        if (!d.textObj) {
            for (let poolText of damageTextPool) {
                if (!poolText.visible) {
                    d.textObj = poolText;
                    break;
                }
            }
            
            // Skip if no text objects available
            if (!d.textObj) continue;
            
            // Configure the text object
            d.textObj.text = d.displayText || Math.floor(d.damage);
            d.textObj.style.fontSize = d.isCritical ? 20 : 14;
            d.textObj.style.fill = d.color;
            d.textObj.visible = true;
            
            // Make critical hits bold
            d.textObj.style.fontWeight = d.isCritical ? "bold" : "normal";
        }
        
        // Update text properties
        d.textObj.position.set(d.x, d.y);
        d.textObj.alpha = d.alpha;
    }
    
    // Draw explosions
    for (let explosion of explosions) {
        // Outer explosion circle
        graphics.beginFill(explosion.color, explosion.alpha * 0.4)
            .drawCircle(explosion.x, explosion.y, explosion.radius)
            .endFill();
            
        // Inner bright core
        graphics.beginFill(0xffffff, explosion.alpha * 0.7)
            .drawCircle(explosion.x, explosion.y, explosion.radius * 0.3)
            .endFill();
            
        // Add a ring at the edge of explosion for better visual
        graphics.lineStyle(2, 0xffdd00, explosion.alpha * 0.8)
            .drawCircle(explosion.x, explosion.y, explosion.radius * 0.8);
    }
    
    // Draw splash effects
    for (let splash of splashEffects) {
        // Outer splash circle
        graphics.beginFill(splash.color, splash.alpha * 0.3)
            .drawCircle(splash.x, splash.y, splash.radius)
            .endFill();
            
        // Inner bright core
        graphics.beginFill(0xffffff, splash.alpha * 0.6)
            .drawCircle(splash.x, splash.y, splash.radius * 0.4)
            .endFill();
            
        // Add a ring at the edge of splash for better visual
        graphics.lineStyle(2, splash.color, splash.alpha * 0.8)
            .drawCircle(splash.x, splash.y, splash.radius * 0.8);
    }
    
    // Draw bomb placement preview
    if (placingBomb) {
        const mx = app.renderer.events.pointer.global?.x || 0;
        const my = app.renderer.events.pointer.global?.y || 0;
        
        // Draw bomb radius preview
        graphics.lineStyle(2, BOMB_CONFIG.color, 0.8)
            .drawCircle(mx, my, BOMB_CONFIG.radius);
            
        // Draw bomb icon
        graphics.beginFill(BOMB_CONFIG.color, 0.7)
            .drawCircle(mx, my, 20)
            .endFill();
            
        // Add crosshair to help with aiming
        graphics.lineStyle(2, 0xffffff, 0.8)
            .moveTo(mx - 10, my)
            .lineTo(mx + 10, my)
            .moveTo(mx, my - 10)
            .lineTo(mx, my + 10);
    }
}

// --- Enemy Stats Hover ---
app.view.addEventListener('mousemove', e => {
    // Only show hover stats if no enemy is currently selected
    if (selectedEnemy) return;
    
    const rect = app.view.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    let found = null;
    for (let enemy of enemies) {
        let r = enemy.type.name === "Boss" ? TILE_SIZE/1.7 : TILE_SIZE/2.5;
        if (Math.hypot(enemy.x-mx, enemy.y-my) < r) {
            found = enemy;
            break;
        }
    }
    if (found) {
        showStats(found);
    } else {
        hideStats();
    }
});

// --- Game Start/End/Over ---
function showGameOver(msg) {
    let over = document.createElement('div');
    over.style.position = 'fixed';
    over.style.left = '50%';
    over.style.top = '50%';
    over.style.transform = 'translate(-50%,-50%)';
    over.style.background = '#23273a';
    over.style.color = '#fff';
    over.style.padding = '32px 48px';
    over.style.borderRadius = '16px';
    over.style.fontSize = '2em';
    over.style.boxShadow = '0 2px 24px #000a';
    
    // Only show New Game button (removed Restart)
    over.innerHTML = `
        <b>${msg}</b><br>
        <button id="new-game-btn" style="margin-top: 20px; background: #de6e6e;">New Game</button>
    `;
    
    document.body.appendChild(over);
    
    // New Game button - clears localStorage
    over.querySelector('#new-game-btn').onclick = () => {
        // Clear ALL game-related localStorage
        localStorage.removeItem('purchasedTowers');
        document.body.removeChild(over);
        restartGame(true);  // true = clear localStorage
    };
}

// Updated restartGame function to accept a parameter
function restartGame(clearStorage = true) {
    towers = [];
    enemies = [];
    projectiles = [];
    damageNumbers = [];
    items = [];
    activeEffects = [];
    explosions = [];
    splashEffects = []; // Clear splash effects
    enemySpawnQueue = []; // Clear spawn queue
    gold = CONFIG.gameSettings.startingGold;
    wave = 1;
    lives = CONFIG.gameSettings.startingLives;
    isGameRunning = false;
    bombCount = 0;
    placingBomb = false;
    spawningWave = false; // Reset spawning flag
    
    // Clear cached wave patterns when restarting
    cachedWavePatterns = {};
    
    // Reset tower types to default towers from config (ONLY base towers)
    TOWER_TYPES = CONFIG.towers.map(tower => ({
        name: tower.name,
        key: tower.key,
        color: parseInt(tower.color),
        range: tower.range,
        cost: tower.cost,
        fireRate: tower.fireRate,
        damage: tower.damage,
        damageVariation: tower.damageVariation,
        critChance: tower.critChance,
        critMultiplier: tower.critMultiplier,
        element: tower.element || "physical",
        splashRadius: tower.splashRadius || 0,
        splashDamageRatio: tower.splashDamageRatio || 0
    }));
    
    // Reset purchased towers array and clear storage if needed
    if (clearStorage) {
        purchasedTowers = [];
        localStorage.clear(); // Clear ALL localStorage to be sure
    } else {
        // Reload purchased towers
        loadPurchasedTowers();
    }
      updatePathGrid();
    updateUI();
    renderTowerSelect();
    renderWaveInfo(); // Only render wave info when actually restarting
    startBtn.style.display = '';
    endBtn.style.display = 'none';
    nextWaveBtn.style.display = 'none';
    
    // Update mobile button visibility
    if (startBtnMobile) startBtnMobile.style.display = '';
    if (endBtnMobile) endBtnMobile.style.display = 'none';
    if (nextWaveBtnMobile) nextWaveBtnMobile.style.display = 'none';
    
    // Reset the text pool when restarting
    damageTextPool.forEach(text => {
        text.visible = false;
    });
}

// Load the game
loadConfig();
    </script>
</body>
</html>
