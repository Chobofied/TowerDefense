<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>PixiJS Tower Defense</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js"></script>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            background: #181c25;
            font-family: 'Segoe UI', Arial, sans-serif;
            overflow: hidden;
        }
        #game-ui {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            pointer-events: none;
        }
        #ui-right-panel {
            position: absolute;
            top: 0;
            left: calc(50% + 384px); /* 16*48/2 = 384, grid centered */
            width: 260px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 24px;
            z-index: 20;
            pointer-events: auto;
        }
        #live-stats {
            position: static;
            background: rgba(30,34,44,0.95);
            border-radius: 12px;
            box-shadow: 0 2px 16px #0008;
            color: #fff;
            padding: 10px 32px;
            font-size: 1.2em;
            z-index: 10;
            margin-top: 32px;
            margin-bottom: 8px;
            pointer-events: auto;
        }
        #tower-select {
            position: static;
            display: flex;
            flex-direction: column;
            gap: 16px;
            z-index: 10;
            pointer-events: auto;
        }
        #start-btn, #end-btn, #next-wave-btn {
            background: #4e6fae;
            border: none;
            border-radius: 8px;
            color: #fff;
            font-size: 1.1em;
            padding: 8px 24px;
            margin: 8px 0;
            cursor: pointer;
            transition: background 0.2s;
            pointer-events: auto;
            width: 180px;
            text-align: left;
        }
        #start-btn:hover, #end-btn:hover, #next-wave-btn:hover {
            background: #6e8fde;
        }
        #stats-panel {
            position: absolute;
            right: 0; top: 0;
            min-width: 220px;
        }
        /* Add message container for dropped items */
        #message-container {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 100;
        }
        .game-message {
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 16px;
            border-radius: 4px;
            margin: 4px 0;
            opacity: 1;
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <div id="game-ui">
        <div id="message-container"></div>
        <div id="ui-right-panel">
            <div class="ui-panel" id="live-stats">
                <span>Wave: <span id="wave-num">1</span></span> |
                <span>Gold: <span id="gold">500</span></span> |
                <span>Lives: <span id="lives">20</span></span> |
                <span>Enemies Left: <span id="enemies-left">0</span></span>
            </div>
            <div class="ui-panel" id="tower-select"></div>
            <button id="start-btn">Start Game</button>
            <button id="end-btn" style="display:none;">End Game</button>
            <button id="next-wave-btn" style="display:none;">Next Wave</button>
        </div>
        <div class="ui-panel" id="stats-panel" style="display:none;"></div>
    </div>
    <script>
// --- Game Constants ---
const GRID_SIZE = 16;
const TILE_SIZE = 48;
const MAP_WIDTH = GRID_SIZE * TILE_SIZE;
const MAP_HEIGHT = GRID_SIZE * TILE_SIZE;
const ENEMY_PATH_COLOR = 0x4e6fae;
const TOWER_COLORS = [0x4e6fae, 0x6ede8a, 0xde6e6e, 0xf2e96d];
const ENEMY_COLORS = [0xde6e6e, 0x6ede8a, 0x6e9ede, 0xf2e96d, 0xcccccc];
const FLYING_COLOR = 0xcccccc;
const BOSS_COLOR = 0xf2e96d;
const TOWER_TYPES = [
    {name: 'Cannon', key: 'Q', color: 0x4e6fae, cost: 50, range: 120, fireRate: 0.8, damage: 18, 
     damageVariation: 0.2, critChance: 0.1, critMultiplier: 2.0},
    {name: 'Laser', key: 'W', color: 0xde6e6e, cost: 70, range: 100, fireRate: 0.4, damage: 10, 
     damageVariation: 0.15, critChance: 0.15, critMultiplier: 1.8},
    {name: 'Missile', key: 'E', color: 0x6ede8a, cost: 90, range: 160, fireRate: 1.2, damage: 30, 
     damageVariation: 0.25, critChance: 0.08, critMultiplier: 2.5},
    {name: 'Tesla', key: 'R', color: 0xf2e96d, cost: 120, range: 90, fireRate: 0.2, damage: 5, 
     damageVariation: 0.1, critChance: 0.2, critMultiplier: 1.5}
];
const ENEMY_TYPES = [
    {name: 'Walker', baseSpeed: 1.2, baseHp: 40, reward: 10, color: ENEMY_COLORS[0], waveScaling: {hp: 0.1, speed: 0.03}},
    {name: 'Runner', baseSpeed: 2.2, baseHp: 20, reward: 8, color: ENEMY_COLORS[1], waveScaling: {hp: 0.07, speed: 0.05}},
    {name: 'Tank', baseSpeed: 0.7, baseHp: 120, reward: 25, color: ENEMY_COLORS[2], waveScaling: {hp: 0.15, speed: 0.02}},
    {name: 'Flying', baseSpeed: 1.7, baseHp: 30, reward: 12, color: FLYING_COLOR, flying: true, waveScaling: {hp: 0.09, speed: 0.04}}
];
const BOSS_TYPE = {name: 'Boss', baseSpeed: 1.1, baseHp: 400, reward: 100, color: BOSS_COLOR, waveScaling: {hp: 0.25, speed: 0.03}};
const MAX_WAVES = 15;
const ITEM_DROP_CHANCE = 0.15; // 15% chance for enemies to drop items
const ITEM_TYPES = [
    {name: "Gold", value: 25, color: 0xffd700, weight: 50},
    {name: "Damage Boost", value: 0.3, duration: 10, color: 0xff4500, weight: 25}, // 30% damage boost for 10 seconds
    {name: "Speed Boost", value: 0.5, duration: 8, color: 0x00ffff, weight: 25}    // 50% fire rate boost for 8 seconds
];

// --- PixiJS Setup ---
const app = new PIXI.Application({
    width: MAP_WIDTH,
    height: MAP_HEIGHT,
    backgroundColor: 0x23273a,
    antialias: true
});
document.body.appendChild(app.view);
app.view.style.display = 'block';
app.view.style.margin = '0 auto';
app.view.style.position = 'absolute';
app.view.style.left = '50%';
app.view.style.top = '50%';
app.view.style.transform = 'translate(-50%, -50%)';

// --- Game State ---
let towers = [];
let enemies = [];
let projectiles = [];
let damageNumbers = [];
let items = []; // For dropped items
let activeEffects = []; // Track active item effects
let gold = 500; // Start with more gold
let wave = 1;
let lives = 20;
let placingTower = null;
let selectedTowerType = -1; // Changed from 0 to -1 to represent "no tower selected"
let selectedEnemy = null;
let isGameRunning = false;
let pathGrid = [];
let startTile = {x: 0, y: Math.floor(GRID_SIZE/2)};
let endTile = {x: GRID_SIZE-1, y: Math.floor(GRID_SIZE/2)};
let flyingBypass = true;
let towerStatsWindow = null; // Add this to track the tower stats window
let messageContainer = document.getElementById('message-container');

// --- UI Setup ---
const towerSelect = document.getElementById('tower-select');
const wavePanel = document.getElementById('wave-panel');
const statsPanel = document.getElementById('stats-panel');
const waveNum = document.getElementById('wave-num');
const goldSpan = document.getElementById('gold');
const startBtn = document.getElementById('start-btn');
const endBtn = document.getElementById('end-btn');
const nextWaveBtn = document.getElementById('next-wave-btn');

// Show game messages function
function showMessage(text, color = "#ffffff") {
    const message = document.createElement('div');
    message.className = 'game-message';
    message.textContent = text;
    message.style.color = color;
    messageContainer.appendChild(message);
    
    // Remove after 3 seconds
    setTimeout(() => {
        message.style.opacity = "0";
        setTimeout(() => messageContainer.removeChild(message), 500);
    }, 3000);
}

function updateUI() {
    waveNum.textContent = wave;
    goldSpan.textContent = gold;
    document.getElementById('lives').textContent = lives;
    document.getElementById('enemies-left').textContent = enemies.filter(e => e.alive).length;
}

function showStats(enemy) {
    statsPanel.style.display = 'block';
    statsPanel.innerHTML = `<b>${enemy.type.name}</b><br>HP: ${Math.ceil(enemy.hp)}/${enemy.maxHp}<br>Speed: ${enemy.speed.toFixed(1)}<br>Reward: ${enemy.type.reward}`;
}
function hideStats() {
    statsPanel.style.display = 'none';
}

// --- Tower Selection UI ---
function renderTowerSelect() {
    towerSelect.innerHTML = '';
    TOWER_TYPES.forEach((t, i) => {
        const btn = document.createElement('button');
        btn.className = 'tower-btn' + (selectedTowerType === i ? ' selected' : '');
        btn.innerHTML = `<b>${t.name}</b><br><small>[${t.key}]</small><br>Cost: ${t.cost}`;
        btn.onclick = () => {
            selectedTowerType = i;
            // Close tower stats window if one is open
            if (towerStatsWindow) {
                document.body.removeChild(towerStatsWindow);
                towerStatsWindow = null;
            }
            renderTowerSelect();
        };
        towerSelect.appendChild(btn);
    });
}
renderTowerSelect();

// --- Hotkeys for Tower Selection ---
document.addEventListener('keydown', e => {
    const idx = TOWER_TYPES.findIndex(t => t.key.toLowerCase() === e.key.toLowerCase());
    if (idx !== -1) {
        selectedTowerType = idx;
        renderTowerSelect();
    }
});

// --- Pathfinding (A*) ---
function createGrid() {
    let grid = [];
    for (let y = 0; y < GRID_SIZE; y++) {
        let row = [];
        for (let x = 0; x < GRID_SIZE; x++) {
            row.push({x, y, blocked: false});
        }
        grid.push(row);
    }
    return grid;
}
function updatePathGrid() {
    pathGrid = createGrid();
    towers.forEach(t => {
        pathGrid[t.y][t.x].blocked = true;
    });
}
function heuristic(a, b) {
    return Math.abs(a.x - b.x) + Math.abs(a.y - b.y);
}
function neighbors(node) {
    let dirs = [[1,0],[-1,0],[0,1],[0,-1]];
    let result = [];
    for (let d of dirs) {
        let nx = node.x + d[0], ny = node.y + d[1];
        if (nx >= 0 && nx < GRID_SIZE && ny >= 0 && ny < GRID_SIZE && !pathGrid[ny][nx].blocked) {
            result.push(pathGrid[ny][nx]);
        }
    }
    return result;
}
function aStar(start, end) {
    let open = [pathGrid[start.y][start.x]];
    let cameFrom = new Map();
    let gScore = Array(GRID_SIZE).fill().map(()=>Array(GRID_SIZE).fill(Infinity));
    gScore[start.y][start.x] = 0;
    let fScore = Array(GRID_SIZE).fill().map(()=>Array(GRID_SIZE).fill(Infinity));
    fScore[start.y][start.x] = heuristic(start, end);
    while (open.length) {
        open.sort((a,b)=>fScore[a.y][a.x]-fScore[b.y][b.x]);
        let current = open.shift();
        if (current.x === end.x && current.y === end.y) {
            let path = [];
            let node = current;
            while (cameFrom.has(node)) {
                path.push(node);
                node = cameFrom.get(node);
            }
            path.push(pathGrid[start.y][start.x]);
            return path.reverse();
        }
        for (let neighbor of neighbors(current)) {
            let tentative = gScore[current.y][current.x] + 1;
            if (tentative < gScore[neighbor.y][neighbor.x]) {
                cameFrom.set(neighbor, current);
                gScore[neighbor.y][neighbor.x] = tentative;
                fScore[neighbor.y][neighbor.x] = tentative + heuristic(neighbor, end);
                if (!open.includes(neighbor)) open.push(neighbor);
            }
        }
    }
    return null;
}

// --- Tower Placement ---
let previewTile = null;
let selectedTower = null;
app.view.addEventListener('mousemove', e => {
    const rect = app.view.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const tx = Math.floor(mx / TILE_SIZE);
    const ty = Math.floor(my / TILE_SIZE);
    // Only show preview if in bounds and not on start/end/tower and a tower type is selected
    if (
        selectedTowerType >= 0 && 
        tx >= 0 && tx < GRID_SIZE && ty >= 0 && ty < GRID_SIZE &&
        !(tx === startTile.x && ty === startTile.y) &&
        !(tx === endTile.x && ty === endTile.y) &&
        !towers.some(t => t.x === tx && t.y === ty)
    ) {
        previewTile = {x: tx, y: ty};
    } else {
        previewTile = null;
    }
});
app.view.addEventListener('mouseleave', () => {
    previewTile = null;
});
// --- Tower Click Handler ---
app.view.addEventListener('click', e => {
    const rect = app.view.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const tx = Math.floor(mx / TILE_SIZE);
    const ty = Math.floor(my / TILE_SIZE);
    
    // Close any existing tower stats window
    if (towerStatsWindow) {
        document.body.removeChild(towerStatsWindow);
        towerStatsWindow = null;
    }
    
    // Check if clicking on an item
    let clickedItem = null;
    for (let i = 0; i < items.length; i++) {
        const item = items[i];
        if (Math.hypot(item.x - mx, item.y - my) < 20) {
            clickedItem = items[i];
            break;
        }
    }
    
    // Handle item collection
    if (clickedItem) {
        collectItem(clickedItem);
        items = items.filter(item => item !== clickedItem);
        return;
    }
    
    // If clicking on a tower, select it and show stats
    let tower = towers.find(t => t.x === tx && t.y === ty);
    if (tower) {
        selectedTower = tower;
        showTowerStats(tower, e.clientX, e.clientY);
        selectedTowerType = -1; // Deselect tower type when selecting a placed tower
        renderTowerSelect();
        updateUI();
        return;
    } else {
        selectedTower = null;
    }
    
    // Only place tower if a tower type is selected (selectedTowerType >= 0)
    if (selectedTowerType >= 0) {
        if (tx < 0 || tx >= GRID_SIZE || ty < 0 || ty >= GRID_SIZE) return;
        if (towers.some(t => t.x === tx && t.y === ty)) return;
        if (tx === startTile.x && ty === startTile.y) return;
        if (tx === endTile.x && ty === endTile.y) return;
        if (gold < TOWER_TYPES[selectedTowerType].cost) return;
        
        towers.push({
            x: tx, y: ty, type: TOWER_TYPES[selectedTowerType], level: 1, cooldown: 0
        });
        gold -= TOWER_TYPES[selectedTowerType].cost;
        updatePathGrid();
        
        // Recalculate path for all non-flying, alive enemies
        enemies.forEach(e => {
            if (!e.flying && e.alive) {
                e.path = aStar({x: Math.round((e.x-TILE_SIZE/2)/TILE_SIZE), y: Math.round((e.y-TILE_SIZE/2)/TILE_SIZE)}, endTile);
                e.pathIdx = 0;
            }
        });
        
        let path = aStar(startTile, endTile);
        if (!path) {
            let t = towers.pop();
            gold += TOWER_TYPES[selectedTowerType].cost;
            updatePathGrid();
            let blocking = towers.filter(tw => {
                towers = towers.filter(tt => tt !== tw);
                updatePathGrid();
                let p = aStar(startTile, endTile);
                towers.push(tw);
                updatePathGrid();
                return !p;
            });
            if (blocking.length) {
                let destroyed = blocking[Math.floor(Math.random()*blocking.length)];
                towers = towers.filter(tw => tw !== destroyed);
                updatePathGrid();
                let g = new PIXI.Graphics();
                g.beginFill(0xde6e6e).drawRect(destroyed.x*TILE_SIZE, destroyed.y*TILE_SIZE, TILE_SIZE, TILE_SIZE).endFill();
                app.stage.addChild(g);
                setTimeout(()=>app.stage.removeChild(g), 500);
            }
        }
        
        // Deselect tower type after placement
        selectedTowerType = -1;
        renderTowerSelect();
        updateUI();
    }
});

// --- Enemy Spawning ---
let spawningWave = false;
function spawnWave() {
    spawningWave = true;
    let count = 8 + wave * 2;
    
    // Apply wave scaling to enemies
    let types = ENEMY_TYPES.map(enemy => {
        // Calculate HP and speed scaling based on wave number
        const hpScale = 1 + (wave - 1) * enemy.waveScaling.hp;
        const speedScale = 1 + (wave - 1) * enemy.waveScaling.speed;
        
        return {
            ...enemy,
            hp: Math.round(enemy.baseHp * hpScale),
            speed: enemy.baseSpeed * speedScale
        };
    });
    
    // Scale boss on boss waves
    if (wave % 5 === 0) {
        const hpScale = 1 + (wave - 1) * BOSS_TYPE.waveScaling.hp;
        const speedScale = 1 + (wave - 1) * BOSS_TYPE.waveScaling.speed;
        
        types.push({
            ...BOSS_TYPE,
            hp: Math.round(BOSS_TYPE.baseHp * hpScale),
            speed: BOSS_TYPE.baseSpeed * speedScale
        });
    }
    
    // Create all enemies at once with slight position offsets
    for (let i = 0; i < count; i++) {
        let type = types[Math.floor(Math.random()*types.length)];
        
        // Boss is always first on boss waves
        if (wave % 5 === 0 && i === 0) {
            type = types.find(t => t.name === "Boss");
        }
        
        // Add offset to x position to prevent complete overlap
        const xOffset = i * 10;
        enemies.push({
            type,
            x: startTile.x * TILE_SIZE + TILE_SIZE/2 - xOffset,
            y: startTile.y * TILE_SIZE + TILE_SIZE/2,
            hp: type.hp,
            maxHp: type.hp, // Store max HP for health bar calculation
            speed: type.speed,
            path: type.flying ? null : aStar(startTile, endTile),
            pathIdx: 0,
            flying: !!type.flying,
            alive: true
        });
    }
    
    showMessage(`Wave ${wave} starting!`, "#6e8fde");
    spawningWave = false;
}

// --- Calculate damage with randomness and crits ---
function calculateDamage(tower) {
    const baseDamage = tower.type.damage * tower.level;
    const variation = tower.type.damageVariation;
    
    // Random damage variation (e.g., ±20%)
    const randomFactor = 1 + (Math.random() * variation * 2 - variation);
    let damage = baseDamage * randomFactor;
    
    // Critical hit check
    const isCritical = Math.random() < tower.type.critChance;
    if (isCritical) {
        damage *= tower.type.critMultiplier;
    }
    
    return {
        damage: Math.round(damage * 10) / 10, // Round to 1 decimal
        isCritical
    };
}

// --- Item Drops ---
function tryDropItem(x, y) {
    if (Math.random() < ITEM_DROP_CHANCE) {
        // Weighted random selection of item type
        const totalWeight = ITEM_TYPES.reduce((sum, item) => sum + item.weight, 0);
        let roll = Math.random() * totalWeight;
        let selectedItem = null;
        
        for (const item of ITEM_TYPES) {
            roll -= item.weight;
            if (roll <= 0) {
                selectedItem = {...item};
                break;
            }
        }
        
        if (selectedItem) {
            items.push({
                x, y,
                type: selectedItem,
                pulseDirection: 1,
                pulseValue: 0,
                lifetime: 300 // Item disappears after 5 seconds (60 frames/sec)
            });
        }
    }
}

// --- Collect Item ---
function collectItem(item) {
    if (item.type.name === "Gold") {
        gold += item.type.value;
        showMessage(`+${item.type.value} Gold!`, "#ffd700");
    }
    else if (item.type.name === "Damage Boost") {
        activeEffects.push({
            type: "damage",
            multiplier: item.type.value,
            duration: item.type.duration * 60 // Convert to frames
        });
        showMessage(`Damage Boost +${Math.round(item.type.value * 100)}% for ${item.type.duration}s!`, "#ff4500");
    }
    else if (item.type.name === "Speed Boost") {
        activeEffects.push({
            type: "fireRate",
            multiplier: item.type.value,
            duration: item.type.duration * 60 // Convert to frames
        });
        showMessage(`Fire Rate Boost +${Math.round(item.type.value * 100)}% for ${item.type.duration}s!`, "#00ffff");
    }
}

// --- Game Loop ---
let endlessMode = true;
function gameLoop(delta) {
    // Update item lifetimes and animations
    for (let i = items.length - 1; i >= 0; i--) {
        const item = items[i];
        item.lifetime--;
        
        // Pulse animation
        item.pulseValue += 0.05 * item.pulseDirection;
        if (item.pulseValue > 1) {
            item.pulseValue = 1;
            item.pulseDirection = -1;
        } else if (item.pulseValue < 0) {
            item.pulseValue = 0;
            item.pulseDirection = 1;
        }
        
        // Remove expired items
        if (item.lifetime <= 0) {
            items.splice(i, 1);
        }
    }
    
    // Update active effects
    for (let i = activeEffects.length - 1; i >= 0; i--) {
        const effect = activeEffects[i];
        effect.duration--;
        if (effect.duration <= 0) {
            showMessage(`${effect.type === 'damage' ? 'Damage' : 'Fire Rate'} boost expired`, "#aaaaaa");
            activeEffects.splice(i, 1);
        }
    }
    
    // --- Move Enemies ---
    for (let enemy of enemies) {
        if (!enemy.alive) continue;
        if (enemy.flying) {
            // Flying: straight line
            let dx = (endTile.x*TILE_SIZE+TILE_SIZE/2) - enemy.x;
            let dy = (endTile.y*TILE_SIZE+TILE_SIZE/2) - enemy.y;
            let dist = Math.sqrt(dx*dx+dy*dy);
            if (dist < 6) {
                enemy.alive = false;
                lives--;
                showMessage("Life lost!", "#ff6666");
                continue;
            }
            let spd = enemy.speed * delta * 2.2;
            enemy.x += dx/dist * spd;
            enemy.y += dy/dist * spd;
        } else {
            if (!enemy.path || enemy.pathIdx >= enemy.path.length) {
                enemy.alive = false;
                lives--;
                showMessage("Life lost!", "#ff6666");
                continue;
            }
            let node = enemy.path[enemy.pathIdx];
            let tx = node.x*TILE_SIZE+TILE_SIZE/2;
            let ty = node.y*TILE_SIZE+TILE_SIZE/2;
            let dx = tx - enemy.x;
            let dy = ty - enemy.y;
            let dist = Math.sqrt(dx*dx+dy*dy);
            let spd = enemy.speed * delta * 2.2;
            if (dist < spd) {
                enemy.x = tx;
                enemy.y = ty;
                enemy.pathIdx++;
            } else {
                enemy.x += dx/dist * spd;
                enemy.y += dy/dist * spd;
            }
        }
    }
    // --- Towers Attack ---
    for (let tower of towers) {
        // Apply fire rate boost if active
        let fireRateMultiplier = 1;
        const fireRateEffect = activeEffects.find(e => e.type === "fireRate");
        if (fireRateEffect) {
            fireRateMultiplier = 1 + fireRateEffect.multiplier;
        }
        
        tower.cooldown -= (delta/60) * fireRateMultiplier;
        if (tower.cooldown <= 0) {
            // All towers can hit flying enemies now
            let targets = enemies.filter(e => e.alive && Math.hypot(e.x-(tower.x*TILE_SIZE+TILE_SIZE/2), e.y-(tower.y*TILE_SIZE+TILE_SIZE/2)) < tower.type.range);
            if (targets.length) {
                let target = targets[0];
                
                // Calculate damage with randomness and critical hits
                const { damage, isCritical } = calculateDamage(tower);
                
                // Apply damage boost if active
                let finalDamage = damage;
                const damageEffect = activeEffects.find(e => e.type === "damage");
                if (damageEffect) {
                    finalDamage *= (1 + damageEffect.multiplier);
                }
                
                projectiles.push({
                    x: tower.x*TILE_SIZE+TILE_SIZE/2,
                    y: tower.y*TILE_SIZE+TILE_SIZE/2,
                    tx: target.x,
                    ty: target.y,
                    target,
                    damage: finalDamage,
                    color: tower.type.color,
                    isCritical, // Track if this was a critical hit
                    speed: 7 + tower.level*2
                });
                tower.cooldown = tower.type.fireRate;
            }
        }
    }
    // --- Projectiles ---
    for (let p of projectiles) {
        let dx = p.tx - p.x;
        let dy = p.ty - p.y;
        let dist = Math.sqrt(dx*dx+dy*dy);
        let spd = p.speed;
        if (dist < spd) {
            p.x = p.tx; p.y = p.ty;
            if (p.target && p.target.alive) {
                p.target.hp -= p.damage;
                // Create damage number when projectile hits
                createDamageNumber(p.target.x, p.target.y - 20, p.damage, p.isCritical);
                if (p.target.hp <= 0) {
                    p.target.alive = false;
                    gold += p.target.type.reward;
                    // Try to drop an item
                    tryDropItem(p.target.x, p.target.y);
                }
            }
            p.hit = true;
        } else {
            p.x += dx/dist * spd;
            p.y += dy/dist * spd;
        }
    }
    projectiles = projectiles.filter(p => !p.hit);
    // --- Update damage numbers ---
    for (let i = damageNumbers.length - 1; i >= 0; i--) {
        let d = damageNumbers[i];
        d.life--;
        d.y -= 1; // Move upward
        d.alpha = d.life / 30;
        if (d.life <= 0) {
            damageNumbers.splice(i, 1);
        }
    }
    // --- Remove Dead Enemies ---
    enemies = enemies.filter(e => e.alive);
    // --- Win/Lose ---
    if (lives <= 0) {
        isGameRunning = false;
        endBtn.style.display = '';
        startBtn.style.display = 'none';
        nextWaveBtn.style.display = 'none';
        showGameOver('Game Over!');
    } else if (!spawningWave && enemies.length === 0 && projectiles.length === 0 && isGameRunning) {
        // Wave complete
        showMessage(`Wave ${wave} complete!`, "#6ede8a");
        
        // Endless mode: show next wave button, do not auto-start
        nextWaveBtn.style.display = '';
        isGameRunning = false;
    }
    updateUI();
}
nextWaveBtn.onclick = () => {
    isGameRunning = true;
    nextWaveBtn.style.display = 'none';
    wave++;
    updateUI();
    spawnWave();
};

// --- Tower Stats Window ---
function showTowerStats(tower, x, y) {
    // Create stats window
    let statsWindow = document.createElement('div');
    statsWindow.style.position = 'absolute';
    statsWindow.style.left = (x + 20) + 'px';
    statsWindow.style.top = (y - 20) + 'px';
    statsWindow.style.background = '#23273a';
    statsWindow.style.color = '#fff';
    statsWindow.style.padding = '15px 20px';
    statsWindow.style.borderRadius = '8px';
    statsWindow.style.boxShadow = '0 2px 16px #0008';
    statsWindow.style.zIndex = '1000';
    statsWindow.style.minWidth = '200px';
    statsWindow.style.pointerEvents = 'auto';
    
    // Add close button (X) in the top right
    let closeBtn = document.createElement('div');
    closeBtn.innerHTML = '×';
    closeBtn.style.position = 'absolute';
    closeBtn.style.top = '5px';
    closeBtn.style.right = '10px';
    closeBtn.style.fontSize = '24px';
    closeBtn.style.cursor = 'pointer';
    closeBtn.style.color = '#fff';
    closeBtn.style.lineHeight = '20px';
    closeBtn.onclick = () => {
        document.body.removeChild(statsWindow);
        towerStatsWindow = null;
    };
    
    // Create content elements
    let title = document.createElement('h3');
    title.style.margin = '0 0 10px 0';
    title.textContent = `${tower.type.name} Tower (Level ${tower.level})`;
    
    // Stats container
    let statsContainer = document.createElement('div');
    statsContainer.style.marginBottom = '15px';
    
    // Add stats including damage variation and critical hit info
    const baseDamage = tower.type.damage * tower.level;
    const variation = tower.type.damageVariation;
    const minDamage = Math.floor(baseDamage * (1 - variation));
    const maxDamage = Math.ceil(baseDamage * (1 + variation));
    const critChance = tower.type.critChance * 100;
    const critMultiplier = tower.type.critMultiplier;
    const damagePerSec = baseDamage / tower.type.fireRate;
    
    let stats = [
        `Damage: ${minDamage}-${maxDamage}`,
        `Critical Hit: ${critChance.toFixed(1)}% chance (×${critMultiplier})`,
        `Range: ${tower.type.range}`,
        `Fire Rate: ${(1 / tower.type.fireRate).toFixed(1)}/sec`,
        `DPS: ${damagePerSec.toFixed(1)}`
    ];
    
    stats.forEach(stat => {
        let div = document.createElement('div');
        div.textContent = stat;
        statsContainer.appendChild(div);
    });
    
    // Buttons container
    let buttonsContainer = document.createElement('div');
    buttonsContainer.style.display = 'flex';
    buttonsContainer.style.justifyContent = 'space-between';
    buttonsContainer.style.gap = '10px';
    
    // Upgrade button
    let upgradeBtn = document.createElement('button');
    upgradeBtn.textContent = `Upgrade (${Math.floor(tower.type.cost*0.7*tower.level)})`;
    upgradeBtn.onclick = () => {
        let cost = Math.floor(tower.type.cost*0.7*tower.level);
        if (gold >= cost) {
            gold -= cost;
            tower.level++;
            updateUI();
            // Update the stats window with new values
            document.body.removeChild(statsWindow);
            showTowerStats(tower, x, y);
            showMessage(`Tower upgraded to level ${tower.level}`, "#6ede8a");
        } else {
            showMessage("Not enough gold!", "#ff6666");
        }
    };
    
    // Sell button
    let sellBtn = document.createElement('button');
    sellBtn.textContent = `Sell (${Math.floor(tower.type.cost*0.5*tower.level)})`;
    sellBtn.onclick = () => {
        gold += Math.floor(tower.type.cost*0.5*tower.level);
        towers = towers.filter(t => t !== tower);
        updatePathGrid();
        document.body.removeChild(statsWindow);
        towerStatsWindow = null;
        selectedTower = null;
        updateUI();
    };
    
    // Assemble the window
    statsWindow.appendChild(closeBtn);
    statsWindow.appendChild(title);
    statsWindow.appendChild(statsContainer);
    buttonsContainer.appendChild(upgradeBtn);
    buttonsContainer.appendChild(sellBtn);
    statsWindow.appendChild(buttonsContainer);
    
    document.body.appendChild(statsWindow);
    towerStatsWindow = statsWindow;
    
    // Close the window when clicking outside
    document.addEventListener('mousedown', function closeStatsWindow(e) {
        if (!statsWindow.contains(e.target) && e.target !== statsWindow) {
            document.body.removeChild(statsWindow);
            towerStatsWindow = null;
            document.removeEventListener('mousedown', closeStatsWindow);
        }
    });
}

// --- Damage Numbers ---
function createDamageNumber(x, y, damage, isCritical = false) {
    damageNumbers.push({
        x: x,
        y: y,
        damage: damage,
        alpha: 1,
        life: 30,
        isCritical
    });
}

// --- Drawing ---
let graphics = new PIXI.Graphics();
app.stage.addChild(graphics);
function draw() {
    graphics.clear();
    // Draw grid
    graphics.lineStyle(1, 0x2e3a4e, 0.5);
    for (let x = 0; x <= GRID_SIZE; x++) {
        graphics.moveTo(x*TILE_SIZE, 0);
        graphics.lineTo(x*TILE_SIZE, MAP_HEIGHT);
    }
    for (let y = 0; y <= GRID_SIZE; y++) {
        graphics.moveTo(0, y*TILE_SIZE);
        graphics.lineTo(MAP_WIDTH, y*TILE_SIZE);
    }
    // Draw start/end
    graphics.beginFill(0x6ede8a).drawRect(startTile.x*TILE_SIZE, startTile.y*TILE_SIZE, TILE_SIZE, TILE_SIZE).endFill();
    graphics.beginFill(0xde6e6e).drawRect(endTile.x*TILE_SIZE, endTile.y*TILE_SIZE, TILE_SIZE, TILE_SIZE).endFill();
    // Draw preview tower (only if a tower type is selected)
    if (previewTile && selectedTowerType >= 0) {
        graphics.beginFill(TOWER_TYPES[selectedTowerType].color, 0.35)
            .drawCircle(previewTile.x*TILE_SIZE+TILE_SIZE/2, previewTile.y*TILE_SIZE+TILE_SIZE/2, TILE_SIZE/2.2)
            .endFill();
    }
    
    // Draw towers with visual upgrades
    for (let t of towers) {
        // Base tower shape - size increases with level
        const levelScale = 0.9 + (t.level * 0.1); // Increase size by 10% per level
        const baseSize = TILE_SIZE/2.2 * levelScale;
        
        // Draw the base tower
        graphics.beginFill(t.type.color)
               .drawCircle(t.x*TILE_SIZE+TILE_SIZE/2, t.y*TILE_SIZE+TILE_SIZE/2, baseSize)
               .endFill();
        
        // Add visual indicators for levels
        if (t.level >= 2) {
            // Add an outer ring for level 2+
            graphics.lineStyle(2, 0xffffff, 0.7)
                   .drawCircle(t.x*TILE_SIZE+TILE_SIZE/2, t.y*TILE_SIZE+TILE_SIZE/2, baseSize * 1.15);
        }
        
        if (t.level >= 3) {
            // Add inner detail for level 3+
            graphics.beginFill(0xffffff, 0.5)
                   .drawCircle(t.x*TILE_SIZE+TILE_SIZE/2, t.y*TILE_SIZE+TILE_SIZE/2, baseSize * 0.4)
                   .endFill();
        }
        
        if (t.level >= 4) {
            // Add a second outer ring for level 4+
            graphics.lineStyle(3, 0xffdd00, 0.8)
                   .drawCircle(t.x*TILE_SIZE+TILE_SIZE/2, t.y*TILE_SIZE+TILE_SIZE/2, baseSize * 1.3);
        }
        
        // Only show radius if this tower is selected
        if (selectedTower === t) {
            graphics.lineStyle(2, 0xffffff, 0.2);
            graphics.drawCircle(t.x*TILE_SIZE+TILE_SIZE/2, t.y*TILE_SIZE+TILE_SIZE/2, t.type.range);
        }
    }
    
    // Draw items
    for (let item of items) {
        const pulseSize = 5 + (item.pulseValue * 3);
        graphics.beginFill(item.type.color, 0.8)
               .drawCircle(item.x, item.y, pulseSize)
               .endFill();
        
        // Add a glow effect
        graphics.beginFill(item.type.color, 0.3)
               .drawCircle(item.x, item.y, pulseSize * 1.5)
               .endFill();
    }
    
    // Draw enemies
    for (let e of enemies) {
        // Draw enemy
        graphics.beginFill(e.type.color).drawCircle(e.x, e.y, e.type === BOSS_TYPE ? TILE_SIZE/1.7 : TILE_SIZE/2.5).endFill();
        if (e.type === BOSS_TYPE) {
            graphics.lineStyle(3, 0xffffff, 0.7);
            graphics.drawCircle(e.x, e.y, TILE_SIZE/1.7);
        }
        
        // Draw health bar
        let healthPercentage = e.hp / e.maxHp;
        let barWidth = e.type === BOSS_TYPE ? TILE_SIZE * 1.5 : TILE_SIZE;
        let barHeight = 6;
        let barX = e.x - barWidth / 2;
        let barY = e.y - (e.type === BOSS_TYPE ? TILE_SIZE/1.3 : TILE_SIZE/1.8);
        
        // Background (dark gray)
        graphics.beginFill(0x333333)
            .drawRect(barX, barY, barWidth, barHeight)
            .endFill();
        
        // Health color based on percentage
        let healthColor;
        if (healthPercentage > 0.6) healthColor = 0x66dd66; // Green
        else if (healthPercentage > 0.3) healthColor = 0xdddd66; // Yellow
        else healthColor = 0xdd6666; // Red
        
        // Health bar (colored)
        graphics.beginFill(healthColor)
            .drawRect(barX, barY, barWidth * healthPercentage, barHeight)
            .endFill();
    }
    
    // Draw projectiles
    for (let p of projectiles) {
        graphics.beginFill(p.color).drawCircle(p.x, p.y, 7).endFill();
    }
    
    // Draw damage numbers
    for (let d of damageNumbers) {
        const fontSize = d.isCritical ? 20 : 14;
        const color = d.isCritical ? 0xff5500 : 0xFFFFFF;
        
        let text = new PIXI.Text(Math.floor(d.damage), {
            fontFamily: "Arial",
            fontSize: fontSize,
            fill: color,
            align: "center",
            fontWeight: "bold",
            strokeThickness: 3,
            stroke: 0x000000
        });
        
        text.alpha = d.alpha;
        text.anchor.set(0.5);
        text.position.set(d.x, d.y);
        app.stage.addChild(text);
        
        // Schedule removal of text after rendering
        setTimeout(() => {
            app.stage.removeChild(text);
        }, 50);
    }
}

// --- Enemy Click Stats ---
app.view.addEventListener('mousemove', e => {
    const rect = app.view.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    let found = null;
    for (let enemy of enemies) {
        let r = enemy.type === BOSS_TYPE ? TILE_SIZE/1.7 : TILE_SIZE/2.5;
        if (Math.hypot(enemy.x-mx, enemy.y-my) < r) {
            found = enemy;
            break;
        }
    }
    if (found) {
        showStats(found);
    } else {
        hideStats();
    }
});

// --- Tower Upgrade/Sell ---
app.view.addEventListener('contextmenu', e => {
    e.preventDefault();
    if (!isGameRunning) return;
    const rect = app.view.getBoundingClientRect();
    const mx = e.clientX - rect.left;
    const my = e.clientY - rect.top;
    const tx = Math.floor(mx / TILE_SIZE);
    const ty = Math.floor(my / TILE_SIZE);
    let tower = towers.find(t => t.x === tx && t.y === ty);
    if (tower) {
        // Show upgrade/sell UI
        let menu = document.createElement('div');
        menu.style.position = 'absolute';
        menu.style.left = e.clientX+'px';
        menu.style.top = e.clientY+'px';
        menu.style.background = '#23273a';
        menu.style.color = '#fff';
        menu.style.padding = '10px 18px';
        menu.style.borderRadius = '8px';
        menu.style.boxShadow = '0 2px 12px #0008';
        menu.style.zIndex = 1000;
        menu.innerHTML = `<b>${tower.type.name} Lv.${tower.level}</b><br><button id="upgrade-btn">Upgrade (${Math.floor(tower.type.cost*0.7*tower.level)})</button> <button id="sell-btn">Sell (${Math.floor(tower.type.cost*0.5*tower.level)})</button>`;
        document.body.appendChild(menu);
        menu.querySelector('#upgrade-btn').onclick = () => {
            let cost = Math.floor(tower.type.cost*0.7*tower.level);
            if (gold >= cost) {
                gold -= cost;
                tower.level++;
                updateUI();
            }
            document.body.removeChild(menu);
        };
        menu.querySelector('#sell-btn').onclick = () => {
            gold += Math.floor(tower.type.cost*0.5*tower.level);
            towers = towers.filter(t => t !== tower);
            updatePathGrid();
            document.body.removeChild(menu);
            updateUI();
        };
        document.addEventListener('mousedown', function handler(ev) {
            if (!menu.contains(ev.target)) {
                document.body.removeChild(menu);
                document.removeEventListener('mousedown', handler);
            }
        });
    }
});

// --- Game Start/End ---
function showGameOver(msg) {
    let over = document.createElement('div');
    over.style.position = 'fixed';
    over.style.left = '50%';
    over.style.top = '50%';
    over.style.transform = 'translate(-50%,-50%)';
    over.style.background = '#23273a';
    over.style.color = '#fff';
    over.style.padding = '32px 48px';
    over.style.borderRadius = '16px';
    over.style.fontSize = '2em';
    over.style.boxShadow = '0 2px 24px #000a';
    over.innerHTML = `<b>${msg}</b><br><button id="restart-btn">Restart</button>`;
    document.body.appendChild(over);
    over.querySelector('#restart-btn').onclick = () => {
        document.body.removeChild(over);
        restartGame();
    };
}
function restartGame() {
    towers = [];
    enemies = [];
    projectiles = [];
    damageNumbers = [];
    items = [];
    activeEffects = [];
    gold = 500;
    wave = 1;
    lives = 20;
    isGameRunning = false;
    updatePathGrid();
    updateUI();
    startBtn.style.display = '';
    endBtn.style.display = 'none';
}
startBtn.onclick = () => {
    isGameRunning = true;
    startBtn.style.display = 'none';
    endBtn.style.display = '';
    towers = [];
    enemies = [];
    projectiles = [];
    damageNumbers = [];
    items = [];
    activeEffects = [];
    gold = 500;
    wave = 1;
    lives = 20;
    updatePathGrid();
    updateUI();
    spawnWave();
};
endBtn.onclick = () => {
    isGameRunning = false;
    endBtn.style.display = 'none';
    startBtn.style.display = '';
    showGameOver('Game Ended');
};

// --- Main Loop ---
updatePathGrid();
updateUI();
app.ticker.add((delta) => {
    if (isGameRunning) gameLoop(delta);
    draw();
});
    </script>
<script>
// Auto-start the game when the page loads
window.addEventListener('DOMContentLoaded', () => {
    document.getElementById('start-btn').click();
});
</script>
</body>
</html>
